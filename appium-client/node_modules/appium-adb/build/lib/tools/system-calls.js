"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "DEFAULT_ADB_EXEC_TIMEOUT", {
  enumerable: true,
  get: function () {
    return _helpers.DEFAULT_ADB_EXEC_TIMEOUT;
  }
});
exports.default = void 0;

require("source-map-support/register");

var _path = _interopRequireDefault(require("path"));

var _logger = _interopRequireDefault(require("../logger.js"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _appiumSupport = require("appium-support");

var _helpers = require("../helpers");

var _teen_process = require("teen_process");

var _asyncbox = require("asyncbox");

var _lodash = _interopRequireDefault(require("lodash"));

var _shellQuote = require("shell-quote");

let systemCallMethods = {};
const DEFAULT_ADB_REBOOT_RETRIES = 90;
const LINKER_WARNING_REGEXP = /^WARNING: linker.+$/m;
const PROTOCOL_FAULT_ERROR_REGEXP = new RegExp('protocol fault \\(no status\\)', 'i');
const DEVICE_NOT_FOUND_ERROR_REGEXP = new RegExp(`error: device ('.+' )?not found`, 'i');
const DEVICE_CONNECTING_ERROR_REGEXP = new RegExp('error: device still connecting', 'i');
const CERTS_ROOT = '/system/etc/security/cacerts';
systemCallMethods.getSdkBinaryPath = _lodash.default.memoize(async function getSdkBinaryPath(binaryName) {
  _logger.default.info(`Checking whether ${binaryName} is present`);

  if (this.sdkRoot) {
    return await this.getBinaryFromSdkRoot(binaryName);
  }

  _logger.default.warn(`The ANDROID_HOME environment variable is not set to the Android SDK ` + `root directory path. ANDROID_HOME is required for compatibility ` + `with SDK 23+. Checking along PATH for ${binaryName}.`);

  return await this.getBinaryFromPath(binaryName);
});
systemCallMethods.getCommandForOS = _lodash.default.memoize(function getCommandForOS() {
  return _appiumSupport.system.isWindows() ? 'where' : 'which';
});
systemCallMethods.getBinaryNameForOS = _lodash.default.memoize(function getBinaryNameForOS(binaryName) {
  if (!_appiumSupport.system.isWindows()) {
    return binaryName;
  }

  if (['android', 'apksigner', 'apkanalyzer'].indexOf(binaryName) >= 0 && !binaryName.toLowerCase().endsWith('.bat')) {
    return `${binaryName}.bat`;
  }

  if (!binaryName.toLowerCase().endsWith('.exe')) {
    return `${binaryName}.exe`;
  }

  return binaryName;
});
systemCallMethods.getBinaryFromSdkRoot = _lodash.default.memoize(async function getBinaryFromSdkRoot(binaryName) {
  let binaryLoc = null;
  binaryName = this.getBinaryNameForOS(binaryName);
  let binaryLocs = [_path.default.resolve(this.sdkRoot, 'platform-tools', binaryName), _path.default.resolve(this.sdkRoot, 'emulator', binaryName), _path.default.resolve(this.sdkRoot, 'tools', binaryName), _path.default.resolve(this.sdkRoot, 'tools', 'bin', binaryName)];

  _lodash.default.forEach((await (0, _helpers.getBuildToolsDirs)(this.sdkRoot)), dir => binaryLocs.push(_path.default.resolve(dir, binaryName)));

  for (let loc of binaryLocs) {
    if (await _appiumSupport.fs.exists(loc)) {
      binaryLoc = loc;
      break;
    }
  }

  if (_lodash.default.isNull(binaryLoc)) {
    throw new Error(`Could not find ${binaryName} in ${binaryLocs}. ` + `Do you have the Android SDK installed at '${this.sdkRoot}'?`);
  }

  binaryLoc = binaryLoc.trim();

  _logger.default.info(`Using ${binaryName} from ${binaryLoc}`);

  return binaryLoc;
});

systemCallMethods.getBinaryFromPath = async function getBinaryFromPath(binaryName) {
  let binaryLoc = null;
  let cmd = this.getCommandForOS();

  try {
    let {
      stdout
    } = await (0, _teen_process.exec)(cmd, [binaryName]);

    _logger.default.info(`Using ${binaryName} from ${stdout}`);

    binaryLoc = stdout.trim();
    return binaryLoc;
  } catch (e) {
    throw new Error(`Could not find ${binaryName} Please set the ANDROID_HOME ` + `environment variable with the Android SDK root directory path.`);
  }
};

systemCallMethods.getConnectedDevices = async function getConnectedDevices() {
  _logger.default.debug('Getting connected devices...');

  try {
    let {
      stdout
    } = await (0, _teen_process.exec)(this.executable.path, this.executable.defaultArgs.concat(['devices']));
    let startingIndex = stdout.indexOf('List of devices');

    if (startingIndex === -1) {
      throw new Error(`Unexpected output while trying to get devices. output was: ${stdout}`);
    }

    stdout = stdout.slice(startingIndex);
    let devices = [];

    for (let line of stdout.split('\n')) {
      if (line.trim() !== '' && line.indexOf('List of devices') === -1 && line.indexOf('adb server') === -1 && line.indexOf('* daemon') === -1 && line.indexOf('offline') === -1) {
        let lineInfo = line.split('\t');
        devices.push({
          udid: lineInfo[0],
          state: lineInfo[1]
        });
      }
    }

    _logger.default.debug(`${devices.length} device(s) connected`);

    return devices;
  } catch (e) {
    throw new Error(`Error while getting connected devices. Original error: ${e.message}`);
  }
};

systemCallMethods.getDevicesWithRetry = async function getDevicesWithRetry(timeoutMs = 20000) {
  let start = Date.now();

  _logger.default.debug('Trying to find a connected android device');

  let getDevices = async () => {
    if (Date.now() - start > timeoutMs) {
      throw new Error('Could not find a connected Android device.');
    }

    try {
      let devices = await this.getConnectedDevices();

      if (devices.length < 1) {
        _logger.default.debug('Could not find devices, restarting adb server...');

        await this.restartAdb();
        await (0, _asyncbox.sleep)(200);
        return await getDevices();
      }

      return devices;
    } catch (e) {
      _logger.default.debug('Could not find devices, restarting adb server...');

      await this.restartAdb();
      await (0, _asyncbox.sleep)(200);
      return await getDevices();
    }
  };

  return await getDevices();
};

systemCallMethods.restartAdb = async function restartAdb() {
  if (this.suppressKillServer) {
    _logger.default.debug(`Not restarting abd since 'suppressKillServer' is on`);

    return;
  }

  _logger.default.debug('Restarting adb');

  try {
    await this.killServer();
  } catch (e) {
    _logger.default.error("Error killing ADB server, going to see if it's online anyway");
  }
};

systemCallMethods.killServer = async function killServer() {
  _logger.default.debug(`Killing adb server on port ${this.adbPort}`);

  await (0, _teen_process.exec)(this.executable.path, [...this.executable.defaultArgs, 'kill-server']);
};

systemCallMethods.resetTelnetAuthToken = _lodash.default.memoize(async function resetTelnetAuthToken() {
  const homeFolderPath = process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];

  if (!homeFolderPath) {
    _logger.default.warn(`Cannot find the path to user home folder. Ignoring resetting of emulator's telnet authentication token`);

    return false;
  }

  const dstPath = _path.default.resolve(homeFolderPath, '.emulator_console_auth_token');

  _logger.default.debug(`Overriding ${dstPath} with an empty string to avoid telnet authentication for emulator commands`);

  try {
    await _appiumSupport.fs.writeFile(dstPath, '');
  } catch (e) {
    _logger.default.warn(`Error ${e.message} while resetting the content of ${dstPath}. Ignoring resetting of emulator's telnet authentication token`);

    return false;
  }

  return true;
});

systemCallMethods.adbExecEmu = async function adbExecEmu(cmd) {
  await this.verifyEmulatorConnected();
  await this.resetTelnetAuthToken();
  await this.adbExec(['emu', ...cmd]);
};

systemCallMethods.adbExec = async function adbExec(cmd, opts = {}) {
  if (!cmd) {
    throw new Error('You need to pass in a command to adbExec()');
  }

  opts = _lodash.default.cloneDeep(opts);
  opts.timeout = opts.timeout || this.adbExecTimeout || _helpers.DEFAULT_ADB_EXEC_TIMEOUT;
  opts.timeoutCapName = opts.timeoutCapName || 'adbExecTimeout';
  cmd = _lodash.default.isArray(cmd) ? cmd : [cmd];
  let adbRetried = false;

  const execFunc = async () => {
    try {
      const args = this.executable.defaultArgs.concat(cmd);

      _logger.default.debug(`Running '${this.executable.path} ${(0, _shellQuote.quote)(args)}'`);

      let {
        stdout
      } = await (0, _teen_process.exec)(this.executable.path, args, opts);
      stdout = stdout.replace(LINKER_WARNING_REGEXP, '').trim();
      return stdout;
    } catch (e) {
      const errText = `${e.message}, ${e.stdout}, ${e.stderr}`;
      const protocolFaultError = PROTOCOL_FAULT_ERROR_REGEXP.test(errText);
      const deviceNotFoundError = DEVICE_NOT_FOUND_ERROR_REGEXP.test(errText);
      const deviceConnectingError = DEVICE_CONNECTING_ERROR_REGEXP.test(errText);

      if (protocolFaultError || deviceNotFoundError || deviceConnectingError) {
        _logger.default.info(`Error sending command, reconnecting device and retrying: ${cmd}`);

        await (0, _asyncbox.sleep)(1000);
        await this.getDevicesWithRetry();

        if (adbRetried) {
          adbRetried = true;
          return await execFunc();
        }
      }

      if (e.code === 0 && e.stdout) {
        return e.stdout.replace(LINKER_WARNING_REGEXP, '').trim();
      }

      if (_lodash.default.isNull(e.code)) {
        e.message = `Error executing adbExec. Original error: '${e.message}'. ` + `Try to increase the ${opts.timeout}ms adb execution timeout represented by '${opts.timeoutCapName}' capability`;
      } else {
        e.message = `Error executing adbExec. Original error: '${e.message}'; ` + `Stderr: '${(e.stderr || '').trim()}'; Code: '${e.code}'`;
      }

      throw e;
    }
  };

  return await execFunc();
};

systemCallMethods.shell = async function shell(cmd, opts = {}) {
  const {
    privileged,
    keepPrivileged
  } = opts;
  let shouldRestoreUser = false;

  if (privileged) {
    try {
      shouldRestoreUser = !(await this.adbExec(['root'], opts)).includes('already running as root');
    } catch (err) {
      if (!err.message.includes('adbd cannot run as root')) {
        _logger.default.warn(`Cannot run adbd as root. Original error: ${err.message}`);
      }
    }
  }

  let didCommandFail = false;

  try {
    try {
      return await this.adbExec(_lodash.default.isArray(cmd) ? ['shell', ...cmd] : ['shell', cmd], opts);
    } catch (err) {
      didCommandFail = true;
      throw err;
    }
  } finally {
    if (privileged && shouldRestoreUser && (!keepPrivileged || didCommandFail)) {
      try {
        await this.adbExec(['unroot'], opts);
      } catch (err) {
        _logger.default.warn(`Cannot run adbd as non-root. Original error: ${err.message}`);
      }
    }
  }
};

systemCallMethods.createSubProcess = function createSubProcess(args = []) {
  args = this.executable.defaultArgs.concat(args);

  _logger.default.debug(`Creating ADB subprocess with args: ${JSON.stringify(args)}`);

  return new _teen_process.SubProcess(this.getAdbPath(), args);
};

systemCallMethods.getAdbServerPort = function getAdbServerPort() {
  return this.adbPort;
};

systemCallMethods.getEmulatorPort = async function getEmulatorPort() {
  _logger.default.debug('Getting running emulator port');

  if (this.emulatorPort !== null) {
    return this.emulatorPort;
  }

  try {
    let devices = await this.getConnectedDevices();
    let port = this.getPortFromEmulatorString(devices[0].udid);

    if (port) {
      return port;
    } else {
      throw new Error(`Emulator port not found`);
    }
  } catch (e) {
    throw new Error(`No devices connected. Original error: ${e.message}`);
  }
};

systemCallMethods.getPortFromEmulatorString = function getPortFromEmulatorString(emStr) {
  let portPattern = /emulator-(\d+)/;

  if (portPattern.test(emStr)) {
    return parseInt(portPattern.exec(emStr)[1], 10);
  }

  return false;
};

systemCallMethods.getConnectedEmulators = async function getConnectedEmulators() {
  _logger.default.debug('Getting connected emulators');

  try {
    let devices = await this.getConnectedDevices();
    let emulators = [];

    for (let device of devices) {
      let port = this.getPortFromEmulatorString(device.udid);

      if (port) {
        device.port = port;
        emulators.push(device);
      }
    }

    _logger.default.debug(`${emulators.length} emulator(s) connected`);

    return emulators;
  } catch (e) {
    throw new Error(`Error getting emulators. Original error: ${e.message}`);
  }
};

systemCallMethods.setEmulatorPort = function setEmulatorPort(emPort) {
  this.emulatorPort = emPort;
};

systemCallMethods.setDeviceId = function setDeviceId(deviceId) {
  _logger.default.debug(`Setting device id to ${deviceId}`);

  this.curDeviceId = deviceId;
  let argsHasDevice = this.executable.defaultArgs.indexOf('-s');

  if (argsHasDevice !== -1) {
    this.executable.defaultArgs.splice(argsHasDevice, 2);
  }

  this.executable.defaultArgs.push('-s', deviceId);
};

systemCallMethods.setDevice = function setDevice(deviceObj) {
  let deviceId = deviceObj.udid;
  let emPort = this.getPortFromEmulatorString(deviceId);
  this.setEmulatorPort(emPort);
  this.setDeviceId(deviceId);
};

systemCallMethods.getRunningAVD = async function getRunningAVD(avdName) {
  _logger.default.debug(`Trying to find '${avdName}' emulator`);

  try {
    const emulators = await this.getConnectedEmulators();

    for (const emulator of emulators) {
      this.setEmulatorPort(emulator.port);
      const runningAVDName = await this.sendTelnetCommand('avd name');

      if (_lodash.default.toLower(avdName) === _lodash.default.toLower(runningAVDName)) {
        _logger.default.debug(`Found emulator '${avdName}' on port ${emulator.port}`);

        this.setDeviceId(emulator.udid);
        return emulator;
      }
    }

    _logger.default.debug(`Emulator '${avdName}' not running`);

    return null;
  } catch (e) {
    throw new Error(`Error getting AVD. Original error: ${e.message}`);
  }
};

systemCallMethods.getRunningAVDWithRetry = async function getRunningAVDWithRetry(avdName, timeoutMs = 20000) {
  let runningAvd;

  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        runningAvd = await this.getRunningAVD(avdName.replace('@', ''));
        return runningAvd;
      } catch (e) {
        _logger.default.debug(e.message);

        return false;
      }
    }, {
      waitMs: timeoutMs,
      intervalMs: 1000
    });
  } catch (e) {
    throw new Error(`Error getting AVD with retry. Original error: ${e.message}`);
  }

  return runningAvd;
};

systemCallMethods.killAllEmulators = async function killAllEmulators() {
  let cmd, args;

  if (_appiumSupport.system.isWindows()) {
    cmd = 'TASKKILL';
    args = ['TASKKILL', '/IM', 'emulator.exe'];
  } else {
    cmd = '/usr/bin/killall';
    args = ['-m', 'emulator*'];
  }

  try {
    await (0, _teen_process.exec)(cmd, args);
  } catch (e) {
    throw new Error(`Error killing emulators. Original error: ${e.message}`);
  }
};

systemCallMethods.killEmulator = async function killEmulator(avdName = null, timeout = 60000) {
  if (_appiumSupport.util.hasValue(avdName)) {
    _logger.default.debug(`Killing avd '${avdName}'`);

    const device = await this.getRunningAVD(avdName);

    if (!device) {
      _logger.default.info(`No avd with name '${avdName}' running. Skipping kill step.`);

      return false;
    }
  } else {
    _logger.default.debug(`Killing avd with id '${this.curDeviceId}'`);

    if (!(await this.isEmulatorConnected())) {
      _logger.default.debug(`Emulator with id '${this.curDeviceId}' not connected. Skipping kill step`);

      return false;
    }
  }

  await this.adbExec(['emu', 'kill']);

  _logger.default.debug(`Waiting up to ${timeout}ms until the emulator '${avdName ? avdName : this.curDeviceId}' is killed`);

  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        return _appiumSupport.util.hasValue(avdName) ? !(await this.getRunningAVD(avdName)) : !(await this.isEmulatorConnected());
      } catch (ign) {}

      return false;
    }, {
      waitMs: timeout,
      intervalMs: 2000
    });
  } catch (e) {
    throw new Error(`The emulator '${avdName ? avdName : this.curDeviceId}' is still running after being killed ${timeout}ms ago`);
  }

  _logger.default.info(`Successfully killed the '${avdName ? avdName : this.curDeviceId}' emulator`);

  return true;
};

systemCallMethods.launchAVD = async function launchAVD(avdName, avdArgs, language, country, avdLaunchTimeout = 60000, avdReadyTimeout = 60000, retryTimes = 1) {
  _logger.default.debug(`Launching Emulator with AVD ${avdName}, launchTimeout ` + `${avdLaunchTimeout}ms and readyTimeout ${avdReadyTimeout}ms`);

  let emulatorBinaryPath = await this.getSdkBinaryPath('emulator');

  if (avdName[0] === '@') {
    avdName = avdName.substr(1);
  }

  await this.checkAvdExist(avdName);
  let launchArgs = ['-avd', avdName];

  if (_lodash.default.isString(language)) {
    _logger.default.debug(`Setting Android Device Language to ${language}`);

    launchArgs.push('-prop', `persist.sys.language=${language.toLowerCase()}`);
  }

  if (_lodash.default.isString(country)) {
    _logger.default.debug(`Setting Android Device Country to ${country}`);

    launchArgs.push('-prop', `persist.sys.country=${country.toUpperCase()}`);
  }

  let locale;

  if (_lodash.default.isString(language) && _lodash.default.isString(country)) {
    locale = language.toLowerCase() + '-' + country.toUpperCase();
  } else if (_lodash.default.isString(language)) {
    locale = language.toLowerCase();
  } else if (_lodash.default.isString(country)) {
    locale = country;
  }

  if (_lodash.default.isString(locale)) {
    _logger.default.debug(`Setting Android Device Locale to ${locale}`);

    launchArgs.push('-prop', `persist.sys.locale=${locale}`);
  }

  if (!_lodash.default.isEmpty(avdArgs)) {
    launchArgs.push(...(_lodash.default.isArray(avdArgs) ? avdArgs : avdArgs.split(' ')));
  }

  _logger.default.debug(`Running '${emulatorBinaryPath}' with args: ${JSON.stringify(launchArgs)}`);

  let proc = new _teen_process.SubProcess(emulatorBinaryPath, launchArgs);
  await proc.start(0);
  proc.on('output', (stdout, stderr) => {
    for (let line of (stdout || stderr || '').split('\n').filter(Boolean)) {
      _logger.default.info(`[AVD OUTPUT] ${line}`);
    }
  });
  proc.on('die', (code, signal) => {
    _logger.default.warn(`Emulator avd ${avdName} exited with code ${code}${signal ? `, signal ${signal}` : ''}`);
  });
  await (0, _asyncbox.retry)(retryTimes, async () => await this.getRunningAVDWithRetry(avdName, avdLaunchTimeout));
  await this.waitForEmulatorReady(avdReadyTimeout);
  return proc;
};

systemCallMethods.getAdbVersion = _lodash.default.memoize(async function getAdbVersion() {
  try {
    let adbVersion = (await this.adbExec('version')).replace(/Android\sDebug\sBridge\sversion\s([\d.]*)[\s\w-]*/, '$1');
    let parts = adbVersion.split('.');
    return {
      versionString: adbVersion,
      versionFloat: parseFloat(adbVersion),
      major: parseInt(parts[0], 10),
      minor: parseInt(parts[1], 10),
      patch: parts[2] ? parseInt(parts[2], 10) : undefined
    };
  } catch (e) {
    throw new Error(`Error getting adb version. Original error: '${e.message}'; ` + `Stderr: '${(e.stderr || '').trim()}'; Code: '${e.code}'`);
  }
});

systemCallMethods.checkAvdExist = async function checkAvdExist(avdName) {
  let cmd, result;

  try {
    cmd = await this.getSdkBinaryPath('emulator');
    result = await (0, _teen_process.exec)(cmd, ['-list-avds']);
  } catch (e) {
    let unknownOptionError = new RegExp('unknown option: -list-avds', 'i').test(e.stderr);

    if (!unknownOptionError) {
      throw new Error(`Error executing checkAvdExist. Original error: '${e.message}'; ` + `Stderr: '${(e.stderr || '').trim()}'; Code: '${e.code}'`);
    }

    const sdkVersion = await (0, _helpers.getSdkToolsVersion)();
    let binaryName = 'android';

    if (sdkVersion) {
      if (sdkVersion.major >= 25) {
        binaryName = 'avdmanager';
      }
    } else {
      _logger.default.warn(`Defaulting binary name to '${binaryName}', because SDK version cannot be parsed`);
    }

    cmd = await this.getSdkBinaryPath(binaryName);
    result = await (0, _teen_process.exec)(cmd, ['list', 'avd', '-c']);
  }

  if (result.stdout.indexOf(avdName) === -1) {
    let existings = `(${result.stdout.trim().replace(/[\n]/g, '), (')})`;
    throw new Error(`Avd '${avdName}' is not available. please select your avd name from one of these: '${existings}'`);
  }
};

systemCallMethods.waitForEmulatorReady = async function waitForEmulatorReady(timeoutMs = 20000) {
  try {
    await (0, _asyncbox.waitForCondition)(async () => {
      try {
        if (!(await this.shell(['getprop', 'init.svc.bootanim'])).includes('stopped')) {
          return false;
        }

        return /\d+\[\w+\]/.test((await this.shell(['pm', 'get-install-location'])));
      } catch (err) {
        _logger.default.debug(`Waiting for emulator startup. Intermediate error: ${err.message}`);

        return false;
      }
    }, {
      waitMs: timeoutMs,
      intervalMs: 3000
    });
  } catch (e) {
    throw new Error(`Emulator is not ready within ${timeoutMs}ms`);
  }
};

systemCallMethods.waitForDevice = async function waitForDevice(appDeviceReadyTimeout = 30) {
  this.appDeviceReadyTimeout = appDeviceReadyTimeout;
  const retries = 3;
  const timeout = parseInt(this.appDeviceReadyTimeout, 10) / retries * 1000;
  await (0, _asyncbox.retry)(retries, async () => {
    try {
      await this.adbExec('wait-for-device', {
        timeout
      });
      await this.ping();
    } catch (e) {
      await this.restartAdb();
      await this.getConnectedDevices();
      throw new Error(`Error waiting for the device to be available. Original error: '${e.message}'`);
    }
  });
};

systemCallMethods.reboot = async function reboot(retries = DEFAULT_ADB_REBOOT_RETRIES) {
  await this.shell(['stop'], {
    privileged: true
  });
  await _bluebird.default.delay(2000);
  await this.setDeviceProperty('sys.boot_completed', 0);
  await this.shell(['start'], {
    privileged: true
  });
  const started = process.hrtime();
  await (0, _asyncbox.retryInterval)(retries, 1000, async () => {
    if ((await this.getDeviceProperty('sys.boot_completed')) === '1') {
      return;
    }

    const msg = `Reboot is not completed after ${process.hrtime(started)[0]}s`;

    _logger.default.debug(msg);

    throw new Error(msg);
  });
};

systemCallMethods.root = async function root() {
  try {
    let {
      stdout
    } = await (0, _teen_process.exec)(this.executable.path, ['root']);

    if (stdout && stdout.indexOf('adbd cannot run as root') !== -1) {
      throw new Error(stdout.trim());
    }

    return true;
  } catch (err) {
    _logger.default.warn(`Unable to root adb daemon: '${err.message}'. Continuing`);

    return false;
  }
};

systemCallMethods.unroot = async function unroot() {
  try {
    await (0, _teen_process.exec)(this.executable.path, ['unroot']);
    return true;
  } catch (err) {
    _logger.default.warn(`Unable to unroot adb daemon: '${err.message}'. Continuing`);

    return false;
  }
};

systemCallMethods.isRoot = async function isRoot() {
  return (await this.shell(['whoami'])).trim() === 'root';
};

systemCallMethods.fileExists = async function fileExists(remotePath) {
  let files = await this.ls(remotePath);
  return files.length > 0;
};

systemCallMethods.ls = async function ls(remotePath, opts = []) {
  try {
    let args = ['ls', ...opts, remotePath];
    let stdout = await this.shell(args);
    let lines = stdout.split('\n');
    return lines.map(l => l.trim()).filter(Boolean).filter(l => l.indexOf('No such file') === -1);
  } catch (err) {
    if (err.message.indexOf('No such file or directory') === -1) {
      throw err;
    }

    return [];
  }
};

systemCallMethods.fileSize = async function fileSize(remotePath) {
  try {
    const files = await this.ls(remotePath, ['-la']);

    if (files.length !== 1) {
      throw new Error(`Remote path is not a file`);
    }

    const match = /[rwxsStT\-+]{10}[\s\d]*\s[^\s]+\s+[^\s]+\s+(\d+)/.exec(files[0]);

    if (!match || _lodash.default.isNaN(parseInt(match[1], 10))) {
      throw new Error(`Unable to parse size from list output: '${files[0]}'`);
    }

    return parseInt(match[1], 10);
  } catch (err) {
    throw new Error(`Unable to get file size for '${remotePath}': ${err.message}`);
  }
};

systemCallMethods.installMitmCertificate = async function installMitmCertificate(cert) {
  const openSsl = await (0, _helpers.getOpenSslForOs)();

  if (!_lodash.default.isBuffer(cert)) {
    cert = Buffer.from(cert, 'base64');
  }

  const tmpRoot = await _appiumSupport.tempDir.openDir();

  try {
    const srcCert = _path.default.resolve(tmpRoot, 'source.cer');

    await _appiumSupport.fs.writeFile(srcCert, cert);
    let {
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-noout', '-hash', '-in', srcCert]);
    const certHash = stdout.trim();

    _logger.default.debug(`Got certificate hash: ${certHash}`);

    _logger.default.debug('Preparing certificate content');

    ({
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-in', srcCert], {
      isBuffer: true
    }));
    let dstCertContent = stdout;
    ({
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-in', srcCert, '-text', '-fingerprint', '-noout'], {
      isBuffer: true
    }));
    dstCertContent = Buffer.concat([dstCertContent, stdout]);

    const dstCert = _path.default.resolve(tmpRoot, `${certHash}.0`);

    await _appiumSupport.fs.writeFile(dstCert, dstCertContent);

    _logger.default.debug('Remounting /system in rw mode');

    await (0, _asyncbox.retryInterval)(5, 2000, async () => await this.adbExec(['remount']));

    _logger.default.debug(`Uploading the generated certificate from '${dstCert}' to '${CERTS_ROOT}'`);

    await this.push(dstCert, CERTS_ROOT);

    _logger.default.debug('Remounting /system to confirm changes');

    await this.adbExec(['remount']);
  } catch (err) {
    throw new Error(`Cannot inject the custom certificate. ` + `Is the certificate properly encoded into base64-string? ` + `Do you have root permissions on the device? ` + `Original error: ${err.message}`);
  } finally {
    await _appiumSupport.fs.rimraf(tmpRoot);
  }
};

systemCallMethods.isMitmCertificateInstalled = async function isMitmCertificateInstalled(cert) {
  const openSsl = await (0, _helpers.getOpenSslForOs)();

  if (!_lodash.default.isBuffer(cert)) {
    cert = Buffer.from(cert, 'base64');
  }

  const tmpRoot = await _appiumSupport.tempDir.openDir();
  let certHash;

  try {
    const tmpCert = _path.default.resolve(tmpRoot, 'source.cer');

    await _appiumSupport.fs.writeFile(tmpCert, cert);
    const {
      stdout
    } = await (0, _teen_process.exec)(openSsl, ['x509', '-noout', '-hash', '-in', tmpCert]);
    certHash = stdout.trim();
  } catch (err) {
    throw new Error(`Cannot retrieve the certificate hash. ` + `Is the certificate properly encoded into base64-string? ` + `Original error: ${err.message}`);
  } finally {
    await _appiumSupport.fs.rimraf(tmpRoot);
  }

  const dstPath = _path.default.posix.resolve(CERTS_ROOT, `${certHash}.0`);

  _logger.default.debug(`Checking if the certificate is already installed at '${dstPath}'`);

  return await this.fileExists(dstPath);
};

var _default = systemCallMethods;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90b29scy9zeXN0ZW0tY2FsbHMuanMiXSwibmFtZXMiOlsic3lzdGVtQ2FsbE1ldGhvZHMiLCJERUZBVUxUX0FEQl9SRUJPT1RfUkVUUklFUyIsIkxJTktFUl9XQVJOSU5HX1JFR0VYUCIsIlBST1RPQ09MX0ZBVUxUX0VSUk9SX1JFR0VYUCIsIlJlZ0V4cCIsIkRFVklDRV9OT1RfRk9VTkRfRVJST1JfUkVHRVhQIiwiREVWSUNFX0NPTk5FQ1RJTkdfRVJST1JfUkVHRVhQIiwiQ0VSVFNfUk9PVCIsImdldFNka0JpbmFyeVBhdGgiLCJfIiwibWVtb2l6ZSIsImJpbmFyeU5hbWUiLCJsb2ciLCJpbmZvIiwic2RrUm9vdCIsImdldEJpbmFyeUZyb21TZGtSb290Iiwid2FybiIsImdldEJpbmFyeUZyb21QYXRoIiwiZ2V0Q29tbWFuZEZvck9TIiwic3lzdGVtIiwiaXNXaW5kb3dzIiwiZ2V0QmluYXJ5TmFtZUZvck9TIiwiaW5kZXhPZiIsInRvTG93ZXJDYXNlIiwiZW5kc1dpdGgiLCJiaW5hcnlMb2MiLCJiaW5hcnlMb2NzIiwicGF0aCIsInJlc29sdmUiLCJmb3JFYWNoIiwiZGlyIiwicHVzaCIsImxvYyIsImZzIiwiZXhpc3RzIiwiaXNOdWxsIiwiRXJyb3IiLCJ0cmltIiwiY21kIiwic3Rkb3V0IiwiZSIsImdldENvbm5lY3RlZERldmljZXMiLCJkZWJ1ZyIsImV4ZWN1dGFibGUiLCJkZWZhdWx0QXJncyIsImNvbmNhdCIsInN0YXJ0aW5nSW5kZXgiLCJzbGljZSIsImRldmljZXMiLCJsaW5lIiwic3BsaXQiLCJsaW5lSW5mbyIsInVkaWQiLCJzdGF0ZSIsImxlbmd0aCIsIm1lc3NhZ2UiLCJnZXREZXZpY2VzV2l0aFJldHJ5IiwidGltZW91dE1zIiwic3RhcnQiLCJEYXRlIiwibm93IiwiZ2V0RGV2aWNlcyIsInJlc3RhcnRBZGIiLCJzdXBwcmVzc0tpbGxTZXJ2ZXIiLCJraWxsU2VydmVyIiwiZXJyb3IiLCJhZGJQb3J0IiwicmVzZXRUZWxuZXRBdXRoVG9rZW4iLCJob21lRm9sZGVyUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJwbGF0Zm9ybSIsImRzdFBhdGgiLCJ3cml0ZUZpbGUiLCJhZGJFeGVjRW11IiwidmVyaWZ5RW11bGF0b3JDb25uZWN0ZWQiLCJhZGJFeGVjIiwib3B0cyIsImNsb25lRGVlcCIsInRpbWVvdXQiLCJhZGJFeGVjVGltZW91dCIsIkRFRkFVTFRfQURCX0VYRUNfVElNRU9VVCIsInRpbWVvdXRDYXBOYW1lIiwiaXNBcnJheSIsImFkYlJldHJpZWQiLCJleGVjRnVuYyIsImFyZ3MiLCJyZXBsYWNlIiwiZXJyVGV4dCIsInN0ZGVyciIsInByb3RvY29sRmF1bHRFcnJvciIsInRlc3QiLCJkZXZpY2VOb3RGb3VuZEVycm9yIiwiZGV2aWNlQ29ubmVjdGluZ0Vycm9yIiwiY29kZSIsInNoZWxsIiwicHJpdmlsZWdlZCIsImtlZXBQcml2aWxlZ2VkIiwic2hvdWxkUmVzdG9yZVVzZXIiLCJpbmNsdWRlcyIsImVyciIsImRpZENvbW1hbmRGYWlsIiwiY3JlYXRlU3ViUHJvY2VzcyIsIkpTT04iLCJzdHJpbmdpZnkiLCJTdWJQcm9jZXNzIiwiZ2V0QWRiUGF0aCIsImdldEFkYlNlcnZlclBvcnQiLCJnZXRFbXVsYXRvclBvcnQiLCJlbXVsYXRvclBvcnQiLCJwb3J0IiwiZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyIsImVtU3RyIiwicG9ydFBhdHRlcm4iLCJwYXJzZUludCIsImV4ZWMiLCJnZXRDb25uZWN0ZWRFbXVsYXRvcnMiLCJlbXVsYXRvcnMiLCJkZXZpY2UiLCJzZXRFbXVsYXRvclBvcnQiLCJlbVBvcnQiLCJzZXREZXZpY2VJZCIsImRldmljZUlkIiwiY3VyRGV2aWNlSWQiLCJhcmdzSGFzRGV2aWNlIiwic3BsaWNlIiwic2V0RGV2aWNlIiwiZGV2aWNlT2JqIiwiZ2V0UnVubmluZ0FWRCIsImF2ZE5hbWUiLCJlbXVsYXRvciIsInJ1bm5pbmdBVkROYW1lIiwic2VuZFRlbG5ldENvbW1hbmQiLCJ0b0xvd2VyIiwiZ2V0UnVubmluZ0FWRFdpdGhSZXRyeSIsInJ1bm5pbmdBdmQiLCJ3YWl0TXMiLCJpbnRlcnZhbE1zIiwia2lsbEFsbEVtdWxhdG9ycyIsImtpbGxFbXVsYXRvciIsInV0aWwiLCJoYXNWYWx1ZSIsImlzRW11bGF0b3JDb25uZWN0ZWQiLCJpZ24iLCJsYXVuY2hBVkQiLCJhdmRBcmdzIiwibGFuZ3VhZ2UiLCJjb3VudHJ5IiwiYXZkTGF1bmNoVGltZW91dCIsImF2ZFJlYWR5VGltZW91dCIsInJldHJ5VGltZXMiLCJlbXVsYXRvckJpbmFyeVBhdGgiLCJzdWJzdHIiLCJjaGVja0F2ZEV4aXN0IiwibGF1bmNoQXJncyIsImlzU3RyaW5nIiwidG9VcHBlckNhc2UiLCJsb2NhbGUiLCJpc0VtcHR5IiwicHJvYyIsIm9uIiwiZmlsdGVyIiwiQm9vbGVhbiIsInNpZ25hbCIsIndhaXRGb3JFbXVsYXRvclJlYWR5IiwiZ2V0QWRiVmVyc2lvbiIsImFkYlZlcnNpb24iLCJwYXJ0cyIsInZlcnNpb25TdHJpbmciLCJ2ZXJzaW9uRmxvYXQiLCJwYXJzZUZsb2F0IiwibWFqb3IiLCJtaW5vciIsInBhdGNoIiwidW5kZWZpbmVkIiwicmVzdWx0IiwidW5rbm93bk9wdGlvbkVycm9yIiwic2RrVmVyc2lvbiIsImV4aXN0aW5ncyIsIndhaXRGb3JEZXZpY2UiLCJhcHBEZXZpY2VSZWFkeVRpbWVvdXQiLCJyZXRyaWVzIiwicGluZyIsInJlYm9vdCIsIkIiLCJkZWxheSIsInNldERldmljZVByb3BlcnR5Iiwic3RhcnRlZCIsImhydGltZSIsImdldERldmljZVByb3BlcnR5IiwibXNnIiwicm9vdCIsInVucm9vdCIsImlzUm9vdCIsImZpbGVFeGlzdHMiLCJyZW1vdGVQYXRoIiwiZmlsZXMiLCJscyIsImxpbmVzIiwibWFwIiwibCIsImZpbGVTaXplIiwibWF0Y2giLCJpc05hTiIsImluc3RhbGxNaXRtQ2VydGlmaWNhdGUiLCJjZXJ0Iiwib3BlblNzbCIsImlzQnVmZmVyIiwiQnVmZmVyIiwiZnJvbSIsInRtcFJvb3QiLCJ0ZW1wRGlyIiwib3BlbkRpciIsInNyY0NlcnQiLCJjZXJ0SGFzaCIsImRzdENlcnRDb250ZW50IiwiZHN0Q2VydCIsInJpbXJhZiIsImlzTWl0bUNlcnRpZmljYXRlSW5zdGFsbGVkIiwidG1wQ2VydCIsInBvc2l4Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUtBOztBQUNBOztBQUNBOztBQUNBOztBQUdBLElBQUlBLGlCQUFpQixHQUFHLEVBQXhCO0FBRUEsTUFBTUMsMEJBQTBCLEdBQUcsRUFBbkM7QUFFQSxNQUFNQyxxQkFBcUIsR0FBRyxzQkFBOUI7QUFDQSxNQUFNQywyQkFBMkIsR0FBRyxJQUFJQyxNQUFKLENBQVcsZ0NBQVgsRUFBNkMsR0FBN0MsQ0FBcEM7QUFDQSxNQUFNQyw2QkFBNkIsR0FBRyxJQUFJRCxNQUFKLENBQVksaUNBQVosRUFBOEMsR0FBOUMsQ0FBdEM7QUFDQSxNQUFNRSw4QkFBOEIsR0FBRyxJQUFJRixNQUFKLENBQVcsZ0NBQVgsRUFBNkMsR0FBN0MsQ0FBdkM7QUFFQSxNQUFNRyxVQUFVLEdBQUcsOEJBQW5CO0FBUUFQLGlCQUFpQixDQUFDUSxnQkFBbEIsR0FBcUNDLGdCQUFFQyxPQUFGLENBQVUsZUFBZUYsZ0JBQWYsQ0FBaUNHLFVBQWpDLEVBQTZDO0FBQzFGQyxrQkFBSUMsSUFBSixDQUFVLG9CQUFtQkYsVUFBVyxhQUF4Qzs7QUFDQSxNQUFJLEtBQUtHLE9BQVQsRUFBa0I7QUFDaEIsV0FBTyxNQUFNLEtBQUtDLG9CQUFMLENBQTBCSixVQUExQixDQUFiO0FBQ0Q7O0FBQ0RDLGtCQUFJSSxJQUFKLENBQVUsc0VBQUQsR0FDQyxrRUFERCxHQUVDLHlDQUF3Q0wsVUFBVyxHQUY3RDs7QUFHQSxTQUFPLE1BQU0sS0FBS00saUJBQUwsQ0FBdUJOLFVBQXZCLENBQWI7QUFDRCxDQVRvQyxDQUFyQztBQWtCQVgsaUJBQWlCLENBQUNrQixlQUFsQixHQUFvQ1QsZ0JBQUVDLE9BQUYsQ0FBVSxTQUFTUSxlQUFU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QUFiLEVBQXNCLFlBQXRCLENBQWhCOztBQUNBLFVBQU1qTCxrQkFBR3dDLFNBQUgsQ0FBYWtKLE9BQWIsRUFBc0JkLElBQXRCLENBQU47QUFDQSxVQUFNO0FBQUN0SyxNQUFBQTtBQUFELFFBQVcsTUFBTSx3QkFBS3VLLE9BQUwsRUFBYyxDQUFDLE1BQUQsRUFBUyxRQUFULEVBQW1CLE9BQW5CLEVBQTRCLEtBQTVCLEVBQW1DYSxPQUFuQyxDQUFkLENBQXZCO0FBQ0FMLElBQUFBLFFBQVEsR0FBRy9LLE1BQU0sQ0FBQ0YsSUFBUCxFQUFYO0FBQ0QsR0FMRCxDQUtFLE9BQU8rRCxHQUFQLEVBQVk7QUFDWixVQUFNLElBQUloRSxLQUFKLENBQVcsd0NBQUQsR0FDQywwREFERCxHQUVDLG1CQUFrQmdFLEdBQUcsQ0FBQzdDLE9BQVEsRUFGekMsQ0FBTjtBQUdELEdBVEQsU0FTVTtBQUNSLFVBQU10QixrQkFBR3dMLE1BQUgsQ0FBVVAsT0FBVixDQUFOO0FBQ0Q7O0FBQ0QsUUFBTTFJLE9BQU8sR0FBRzdDLGNBQUtpTSxLQUFMLENBQVdoTSxPQUFYLENBQW1CckIsVUFBbkIsRUFBZ0MsR0FBRStNLFFBQVMsSUFBM0MsQ0FBaEI7O0FBQ0ExTSxrQkFBSThCLEtBQUosQ0FBVyx3REFBdUQ4QixPQUFRLEdBQTFFOztBQUNBLFNBQU8sTUFBTSxLQUFLMEgsVUFBTCxDQUFnQjFILE9BQWhCLENBQWI7QUFDRCxDQXhCRDs7ZUEwQmV4RSxpQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXIuanMnO1xuaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IHsgc3lzdGVtLCBmcywgdXRpbCwgdGVtcERpciB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcbmltcG9ydCB7XG4gIGdldFNka1Rvb2xzVmVyc2lvbixcbiAgZ2V0QnVpbGRUb29sc0RpcnMsXG4gIGdldE9wZW5Tc2xGb3JPcyxcbiAgREVGQVVMVF9BREJfRVhFQ19USU1FT1VUIH0gZnJvbSAnLi4vaGVscGVycyc7XG5pbXBvcnQgeyBleGVjLCBTdWJQcm9jZXNzIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCB7IHNsZWVwLCByZXRyeSwgcmV0cnlJbnRlcnZhbCwgd2FpdEZvckNvbmRpdGlvbiB9IGZyb20gJ2FzeW5jYm94JztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBxdW90ZSB9IGZyb20gJ3NoZWxsLXF1b3RlJztcblxuXG5sZXQgc3lzdGVtQ2FsbE1ldGhvZHMgPSB7fTtcblxuY29uc3QgREVGQVVMVF9BREJfUkVCT09UX1JFVFJJRVMgPSA5MDtcblxuY29uc3QgTElOS0VSX1dBUk5JTkdfUkVHRVhQID0gL15XQVJOSU5HOiBsaW5rZXIuKyQvbTtcbmNvbnN0IFBST1RPQ09MX0ZBVUxUX0VSUk9SX1JFR0VYUCA9IG5ldyBSZWdFeHAoJ3Byb3RvY29sIGZhdWx0IFxcXFwobm8gc3RhdHVzXFxcXCknLCAnaScpO1xuY29uc3QgREVWSUNFX05PVF9GT1VORF9FUlJPUl9SRUdFWFAgPSBuZXcgUmVnRXhwKGBlcnJvcjogZGV2aWNlICgnLisnICk/bm90IGZvdW5kYCwgJ2knKTtcbmNvbnN0IERFVklDRV9DT05ORUNUSU5HX0VSUk9SX1JFR0VYUCA9IG5ldyBSZWdFeHAoJ2Vycm9yOiBkZXZpY2Ugc3RpbGwgY29ubmVjdGluZycsICdpJyk7XG5cbmNvbnN0IENFUlRTX1JPT1QgPSAnL3N5c3RlbS9ldGMvc2VjdXJpdHkvY2FjZXJ0cyc7XG5cbi8qKlxuICogUmV0cmlldmUgZnVsbCBwYXRoIHRvIHRoZSBnaXZlbiBiaW5hcnkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmFyeU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgYmluYXJ5LlxuICogQHJldHVybiB7c3RyaW5nfSBGdWxsIHBhdGggdG8gdGhlIGdpdmVuIGJpbmFyeSBpbmNsdWRpbmcgY3VycmVudCBTREsgcm9vdC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0U2RrQmluYXJ5UGF0aCA9IF8ubWVtb2l6ZShhc3luYyBmdW5jdGlvbiBnZXRTZGtCaW5hcnlQYXRoIChiaW5hcnlOYW1lKSB7XG4gIGxvZy5pbmZvKGBDaGVja2luZyB3aGV0aGVyICR7YmluYXJ5TmFtZX0gaXMgcHJlc2VudGApO1xuICBpZiAodGhpcy5zZGtSb290KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0QmluYXJ5RnJvbVNka1Jvb3QoYmluYXJ5TmFtZSk7XG4gIH1cbiAgbG9nLndhcm4oYFRoZSBBTkRST0lEX0hPTUUgZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbm90IHNldCB0byB0aGUgQW5kcm9pZCBTREsgYCArXG4gICAgICAgICAgIGByb290IGRpcmVjdG9yeSBwYXRoLiBBTkRST0lEX0hPTUUgaXMgcmVxdWlyZWQgZm9yIGNvbXBhdGliaWxpdHkgYCArXG4gICAgICAgICAgIGB3aXRoIFNESyAyMysuIENoZWNraW5nIGFsb25nIFBBVEggZm9yICR7YmluYXJ5TmFtZX0uYCk7XG4gIHJldHVybiBhd2FpdCB0aGlzLmdldEJpbmFyeUZyb21QYXRoKGJpbmFyeU5hbWUpO1xufSk7XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIG5hbWUgb2YgdGhlIHRvb2wsXG4gKiB3aGljaCBwcmludHMgZnVsbCBwYXRoIHRvIHRoZSBnaXZlbiBjb21tYW5kIHNob3J0Y3V0LlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gRGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IHBsYXRmb3JtIHRoaXMgaXNcbiAqICAgICAgICAgICAgICAgICAgc3VwcG9zZWQgdG8gYmUgZWl0aGVyICd3aGljaCcgb3IgJ3doZXJlJy5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0Q29tbWFuZEZvck9TID0gXy5tZW1vaXplKGZ1bmN0aW9uIGdldENvbW1hbmRGb3JPUyAoKSB7XG4gIHJldHVybiBzeXN0ZW0uaXNXaW5kb3dzKCkgPyAnd2hlcmUnIDogJ3doaWNoJztcbn0pO1xuXG4vKipcbiAqIFJldHJpZXZlIGZ1bGwgYmluYXJ5IG5hbWUgZm9yIHRoZSBjdXJyZW50IG9wZXJhdGluZyBzeXN0ZW0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmFyeU5hbWUgLSBzaW1wbGUgYmluYXJ5IG5hbWUsIGZvciBleGFtcGxlICdhbmRyb2lkJy5cbiAqIEByZXR1cm4ge3N0cmluZ30gRm9ybWF0dGVkIGJpbmFyeSBuYW1lIGRlcGVuZGluZyBvbiB0aGUgY3VycmVudCBwbGF0Zm9ybSxcbiAqICAgICAgICAgICAgICAgICAgZm9yIGV4YW1wbGUsICdhbmRyb2lkLmJhdCcgb24gV2luZG93cy5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0QmluYXJ5TmFtZUZvck9TID0gXy5tZW1vaXplKGZ1bmN0aW9uIGdldEJpbmFyeU5hbWVGb3JPUyAoYmluYXJ5TmFtZSkge1xuICBpZiAoIXN5c3RlbS5pc1dpbmRvd3MoKSkge1xuICAgIHJldHVybiBiaW5hcnlOYW1lO1xuICB9XG5cbiAgaWYgKFsnYW5kcm9pZCcsICdhcGtzaWduZXInLCAnYXBrYW5hbHl6ZXInXS5pbmRleE9mKGJpbmFyeU5hbWUpID49IDAgJiZcbiAgICAgICFiaW5hcnlOYW1lLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoJy5iYXQnKSkge1xuICAgIHJldHVybiBgJHtiaW5hcnlOYW1lfS5iYXRgO1xuICB9XG4gIGlmICghYmluYXJ5TmFtZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKCcuZXhlJykpIHtcbiAgICByZXR1cm4gYCR7YmluYXJ5TmFtZX0uZXhlYDtcbiAgfVxuICByZXR1cm4gYmluYXJ5TmFtZTtcbn0pO1xuXG4vKipcbiAqIFJldHJpZXZlIGZ1bGwgcGF0aCB0byB0aGUgZ2l2ZW4gYmluYXJ5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5hcnlOYW1lIC0gU2ltcGxlIG5hbWUgb2YgYSBiaW5hcnkgZmlsZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gRnVsbCBwYXRoIHRvIHRoZSBnaXZlbiBiaW5hcnkuIFRoZSBtZXRob2QgdHJpZXNcbiAqICAgICAgICAgICAgICAgICAgdG8gZW51bWVyYXRlIGFsbCB0aGUga25vd24gbG9jYXRpb25zIHdoZXJlIHRoZSBiaW5hcnlcbiAqICAgICAgICAgICAgICAgICAgbWlnaHQgYmUgbG9jYXRlZCBhbmQgc3RvcHMgdGhlIHNlYXJjaCBhcyBzb29uIGFzIHRoZSBmaXJzdFxuICogICAgICAgICAgICAgICAgICBtYXRjaCBpcyBmb3VuZCBvbiB0aGUgbG9jYWwgZmlsZSBzeXN0ZW0uXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGJpbmFyeSB3aXRoIGdpdmVuIG5hbWUgaXMgbm90IHByZXNlbnQgYXQgYW55XG4gKiAgICAgICAgICAgICAgICAgb2Yga25vd24gbG9jYXRpb25zIG9yIEFuZHJvaWQgU0RLIGlzIG5vdCBpbnN0YWxsZWQgb24gdGhlXG4gKiAgICAgICAgICAgICAgICAgbG9jYWwgZmlsZSBzeXN0ZW0uXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldEJpbmFyeUZyb21TZGtSb290ID0gXy5tZW1vaXplKGFzeW5jIGZ1bmN0aW9uIGdldEJpbmFyeUZyb21TZGtSb290IChiaW5hcnlOYW1lKSB7XG4gIGxldCBiaW5hcnlMb2MgPSBudWxsO1xuICBiaW5hcnlOYW1lID0gdGhpcy5nZXRCaW5hcnlOYW1lRm9yT1MoYmluYXJ5TmFtZSk7XG4gIGxldCBiaW5hcnlMb2NzID0gW1xuICAgIHBhdGgucmVzb2x2ZSh0aGlzLnNka1Jvb3QsICdwbGF0Zm9ybS10b29scycsIGJpbmFyeU5hbWUpLFxuICAgIHBhdGgucmVzb2x2ZSh0aGlzLnNka1Jvb3QsICdlbXVsYXRvcicsIGJpbmFyeU5hbWUpLFxuICAgIHBhdGgucmVzb2x2ZSh0aGlzLnNka1Jvb3QsICd0b29scycsIGJpbmFyeU5hbWUpLFxuICAgIHBhdGgucmVzb2x2ZSh0aGlzLnNka1Jvb3QsICd0b29scycsICdiaW4nLCBiaW5hcnlOYW1lKVxuICBdO1xuICAvLyBnZXQgc3VicGF0aHMgZm9yIGN1cnJlbnRseSBpbnN0YWxsZWQgYnVpbGQgdG9vbCBkaXJlY3Rvcmllc1xuICBfLmZvckVhY2goYXdhaXQgZ2V0QnVpbGRUb29sc0RpcnModGhpcy5zZGtSb290KSxcbiAgICAgICAgICAgIChkaXIpID0+IGJpbmFyeUxvY3MucHVzaChwYXRoLnJlc29sdmUoZGlyLCBiaW5hcnlOYW1lKSkpO1xuICBmb3IgKGxldCBsb2Mgb2YgYmluYXJ5TG9jcykge1xuICAgIGlmIChhd2FpdCBmcy5leGlzdHMobG9jKSkge1xuICAgICAgYmluYXJ5TG9jID0gbG9jO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChfLmlzTnVsbChiaW5hcnlMb2MpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCAke2JpbmFyeU5hbWV9IGluICR7YmluYXJ5TG9jc30uIGAgK1xuICAgICAgICAgICAgICAgICAgICBgRG8geW91IGhhdmUgdGhlIEFuZHJvaWQgU0RLIGluc3RhbGxlZCBhdCAnJHt0aGlzLnNka1Jvb3R9Jz9gKTtcbiAgfVxuICBiaW5hcnlMb2MgPSBiaW5hcnlMb2MudHJpbSgpO1xuICBsb2cuaW5mbyhgVXNpbmcgJHtiaW5hcnlOYW1lfSBmcm9tICR7YmluYXJ5TG9jfWApO1xuICByZXR1cm4gYmluYXJ5TG9jO1xufSk7XG5cbi8qKlxuICogUmV0cmlldmUgZnVsbCBwYXRoIHRvIGEgYmluYXJ5IGZpbGUgdXNpbmcgdGhlIHN0YW5kYXJkIHN5c3RlbSBsb29rdXAgdG9vbC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluYXJ5TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBiaW5hcnkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZ1bGwgcGF0aCB0byB0aGUgYmluYXJ5IHJlY2VpdmVkIGZyb20gJ3doaWNoJy8nd2hlcmUnXG4gKiAgICAgICAgICAgICAgICAgIG91dHB1dC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBsb29rdXAgdG9vbCByZXR1cm5zIG5vbi16ZXJvIHJldHVybiBjb2RlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRCaW5hcnlGcm9tUGF0aCA9IGFzeW5jIGZ1bmN0aW9uIGdldEJpbmFyeUZyb21QYXRoIChiaW5hcnlOYW1lKSB7XG4gIGxldCBiaW5hcnlMb2MgPSBudWxsO1xuICBsZXQgY21kID0gdGhpcy5nZXRDb21tYW5kRm9yT1MoKTtcbiAgdHJ5IHtcbiAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKGNtZCwgW2JpbmFyeU5hbWVdKTtcbiAgICBsb2cuaW5mbyhgVXNpbmcgJHtiaW5hcnlOYW1lfSBmcm9tICR7c3Rkb3V0fWApO1xuICAgIC8vIFRPRE8gd3JpdGUgYSB0ZXN0IGZvciBiaW5hcmllcyB3aXRoIHNwYWNlcy5cbiAgICBiaW5hcnlMb2MgPSBzdGRvdXQudHJpbSgpO1xuICAgIHJldHVybiBiaW5hcnlMb2M7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kICR7YmluYXJ5TmFtZX0gUGxlYXNlIHNldCB0aGUgQU5EUk9JRF9IT01FIGAgK1xuICAgICAgICAgICAgICBgZW52aXJvbm1lbnQgdmFyaWFibGUgd2l0aCB0aGUgQW5kcm9pZCBTREsgcm9vdCBkaXJlY3RvcnkgcGF0aC5gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEZXZpY2VcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1ZGlkIC0gVGhlIGRldmljZSB1ZGlkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXRlIC0gQ3VycmVudCBkZXZpY2Ugc3RhdGUsIGFzIGl0IGlzIHZpc2libGUgaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hZGIgZGV2aWNlcyAtbF8gb3V0cHV0LlxuICovXG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGxpc3Qgb2YgZGV2aWNlcyB2aXNpYmxlIHRvIGFkYi5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheS48RGV2aWNlPn0gVGhlIGxpc3Qgb2YgZGV2aWNlcyBvciBhbiBlbXB0eSBsaXN0IGlmXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgbm8gZGV2aWNlcyBhcmUgY29ubmVjdGVkLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBsaXN0aW5nIGRldmljZXMuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldENvbm5lY3RlZERldmljZXMgPSBhc3luYyBmdW5jdGlvbiBnZXRDb25uZWN0ZWREZXZpY2VzICgpIHtcbiAgbG9nLmRlYnVnKCdHZXR0aW5nIGNvbm5lY3RlZCBkZXZpY2VzLi4uJyk7XG4gIHRyeSB7XG4gICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgdGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLmNvbmNhdChbJ2RldmljZXMnXSkpO1xuICAgIC8vIGV4cGVjdGluZyBhZGIgZGV2aWNlcyB0byByZXR1cm4gb3V0cHV0IGFzXG4gICAgLy8gTGlzdCBvZiBkZXZpY2VzIGF0dGFjaGVkXG4gICAgLy8gZW11bGF0b3ItNTU1NFx0ZGV2aWNlXG4gICAgbGV0IHN0YXJ0aW5nSW5kZXggPSBzdGRvdXQuaW5kZXhPZignTGlzdCBvZiBkZXZpY2VzJyk7XG4gICAgaWYgKHN0YXJ0aW5nSW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgb3V0cHV0IHdoaWxlIHRyeWluZyB0byBnZXQgZGV2aWNlcy4gb3V0cHV0IHdhczogJHtzdGRvdXR9YCk7XG4gICAgfVxuICAgIC8vIHNsaWNpbmcgb3VwdXQgd2UgY2FyZSBhYm91dC5cbiAgICBzdGRvdXQgPSBzdGRvdXQuc2xpY2Uoc3RhcnRpbmdJbmRleCk7XG4gICAgbGV0IGRldmljZXMgPSBbXTtcbiAgICBmb3IgKGxldCBsaW5lIG9mIHN0ZG91dC5zcGxpdCgnXFxuJykpIHtcbiAgICAgIGlmIChsaW5lLnRyaW0oKSAhPT0gJycgJiZcbiAgICAgICAgICBsaW5lLmluZGV4T2YoJ0xpc3Qgb2YgZGV2aWNlcycpID09PSAtMSAmJlxuICAgICAgICAgIGxpbmUuaW5kZXhPZignYWRiIHNlcnZlcicpID09PSAtMSAmJlxuICAgICAgICAgIGxpbmUuaW5kZXhPZignKiBkYWVtb24nKSA9PT0gLTEgJiZcbiAgICAgICAgICBsaW5lLmluZGV4T2YoJ29mZmxpbmUnKSA9PT0gLTEpIHtcbiAgICAgICAgbGV0IGxpbmVJbmZvID0gbGluZS5zcGxpdCgnXFx0Jyk7XG4gICAgICAgIC8vIHN0YXRlIGlzIGVpdGhlciBcImRldmljZVwiIG9yIFwib2ZmbGluZVwiLCBhZmFpY3RcbiAgICAgICAgZGV2aWNlcy5wdXNoKHt1ZGlkOiBsaW5lSW5mb1swXSwgc3RhdGU6IGxpbmVJbmZvWzFdfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxvZy5kZWJ1ZyhgJHtkZXZpY2VzLmxlbmd0aH0gZGV2aWNlKHMpIGNvbm5lY3RlZGApO1xuICAgIHJldHVybiBkZXZpY2VzO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciB3aGlsZSBnZXR0aW5nIGNvbm5lY3RlZCBkZXZpY2VzLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGxpc3Qgb2YgZGV2aWNlcyB2aXNpYmxlIHRvIGFkYiB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRNcyAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZ2V0IGF0IGxlYXN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lIGxpc3QgaXRlbS5cbiAqIEByZXR1cm4ge0FycmF5LjxEZXZpY2U+fSBUaGUgbGlzdCBvZiBjb25uZWN0ZWQgZGV2aWNlcy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBubyBjb25uZWN0ZWQgZGV2aWNlcyBjYW4gYmUgZGV0ZWN0ZWQgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXREZXZpY2VzV2l0aFJldHJ5ID0gYXN5bmMgZnVuY3Rpb24gZ2V0RGV2aWNlc1dpdGhSZXRyeSAodGltZW91dE1zID0gMjAwMDApIHtcbiAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgbG9nLmRlYnVnKCdUcnlpbmcgdG8gZmluZCBhIGNvbm5lY3RlZCBhbmRyb2lkIGRldmljZScpO1xuICBsZXQgZ2V0RGV2aWNlcyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoKERhdGUubm93KCkgLSBzdGFydCkgPiB0aW1lb3V0TXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgYSBjb25uZWN0ZWQgQW5kcm9pZCBkZXZpY2UuJyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBsZXQgZGV2aWNlcyA9IGF3YWl0IHRoaXMuZ2V0Q29ubmVjdGVkRGV2aWNlcygpO1xuICAgICAgaWYgKGRldmljZXMubGVuZ3RoIDwgMSkge1xuICAgICAgICBsb2cuZGVidWcoJ0NvdWxkIG5vdCBmaW5kIGRldmljZXMsIHJlc3RhcnRpbmcgYWRiIHNlcnZlci4uLicpO1xuICAgICAgICBhd2FpdCB0aGlzLnJlc3RhcnRBZGIoKTtcbiAgICAgICAgLy8gY29vbCBkb3duXG4gICAgICAgIGF3YWl0IHNsZWVwKDIwMCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBnZXREZXZpY2VzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGV2aWNlcztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2cuZGVidWcoJ0NvdWxkIG5vdCBmaW5kIGRldmljZXMsIHJlc3RhcnRpbmcgYWRiIHNlcnZlci4uLicpO1xuICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0QWRiKCk7XG4gICAgICAvLyBjb29sIGRvd25cbiAgICAgIGF3YWl0IHNsZWVwKDIwMCk7XG4gICAgICByZXR1cm4gYXdhaXQgZ2V0RGV2aWNlcygpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGF3YWl0IGdldERldmljZXMoKTtcbn07XG5cbi8qKlxuICogUmVzdGFydCBhZGIgc2VydmVyLCB1bmxlc3MgX3RoaXMuc3VwcHJlc3NLaWxsU2VydmVyXyBwcm9wZXJ0eSBpcyB0cnVlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5yZXN0YXJ0QWRiID0gYXN5bmMgZnVuY3Rpb24gcmVzdGFydEFkYiAoKSB7XG4gIGlmICh0aGlzLnN1cHByZXNzS2lsbFNlcnZlcikge1xuICAgIGxvZy5kZWJ1ZyhgTm90IHJlc3RhcnRpbmcgYWJkIHNpbmNlICdzdXBwcmVzc0tpbGxTZXJ2ZXInIGlzIG9uYCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbG9nLmRlYnVnKCdSZXN0YXJ0aW5nIGFkYicpO1xuICB0cnkge1xuICAgIGF3YWl0IHRoaXMua2lsbFNlcnZlcigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmVycm9yKFwiRXJyb3Iga2lsbGluZyBBREIgc2VydmVyLCBnb2luZyB0byBzZWUgaWYgaXQncyBvbmxpbmUgYW55d2F5XCIpO1xuICB9XG59O1xuXG4vKipcbiAqIEtpbGwgYWRiIHNlcnZlci5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMua2lsbFNlcnZlciA9IGFzeW5jIGZ1bmN0aW9uIGtpbGxTZXJ2ZXIgKCkge1xuICBsb2cuZGVidWcoYEtpbGxpbmcgYWRiIHNlcnZlciBvbiBwb3J0ICR7dGhpcy5hZGJQb3J0fWApO1xuICBhd2FpdCBleGVjKHRoaXMuZXhlY3V0YWJsZS5wYXRoLCBbLi4udGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLCAna2lsbC1zZXJ2ZXInXSk7XG59O1xuXG4vKipcbiAqIFJlc2V0IFRlbG5ldCBhdXRoZW50aWNhdGlvbiB0b2tlbi5cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly90b29scy5hbmRyb2lkLmNvbS9yZWNlbnQvZW11bGF0b3IyNTE2cmVsZWFzZW5vdGVzfSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBJZiB0b2tlbiByZXNldCB3YXMgc3VjY2Vzc2Z1bC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMucmVzZXRUZWxuZXRBdXRoVG9rZW4gPSBfLm1lbW9pemUoYXN5bmMgZnVuY3Rpb24gcmVzZXRUZWxuZXRBdXRoVG9rZW4gKCkge1xuICAvLyBUaGUgbWV0aG9kcyBpcyB1c2VkIHRvIHJlbW92ZSB0ZWxuZXQgYXV0aCB0b2tlblxuICAvL1xuICBjb25zdCBob21lRm9sZGVyUGF0aCA9IHByb2Nlc3MuZW52Wyhwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSA/ICdVU0VSUFJPRklMRScgOiAnSE9NRSddO1xuICBpZiAoIWhvbWVGb2xkZXJQYXRoKSB7XG4gICAgbG9nLndhcm4oYENhbm5vdCBmaW5kIHRoZSBwYXRoIHRvIHVzZXIgaG9tZSBmb2xkZXIuIElnbm9yaW5nIHJlc2V0dGluZyBvZiBlbXVsYXRvcidzIHRlbG5ldCBhdXRoZW50aWNhdGlvbiB0b2tlbmApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBkc3RQYXRoID0gcGF0aC5yZXNvbHZlKGhvbWVGb2xkZXJQYXRoLCAnLmVtdWxhdG9yX2NvbnNvbGVfYXV0aF90b2tlbicpO1xuICBsb2cuZGVidWcoYE92ZXJyaWRpbmcgJHtkc3RQYXRofSB3aXRoIGFuIGVtcHR5IHN0cmluZyB0byBhdm9pZCB0ZWxuZXQgYXV0aGVudGljYXRpb24gZm9yIGVtdWxhdG9yIGNvbW1hbmRzYCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKGRzdFBhdGgsICcnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy53YXJuKGBFcnJvciAke2UubWVzc2FnZX0gd2hpbGUgcmVzZXR0aW5nIHRoZSBjb250ZW50IG9mICR7ZHN0UGF0aH0uIElnbm9yaW5nIHJlc2V0dGluZyBvZiBlbXVsYXRvcidzIHRlbG5ldCBhdXRoZW50aWNhdGlvbiB0b2tlbmApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn0pO1xuXG4vKipcbiAqIEV4ZWN1dGUgdGhlIGdpdmVuIGVtdWxhdG9yIGNvbW1hbmQgdXNpbmcgX2FkYiBlbXVfIHRvb2wuXG4gKlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY21kIC0gVGhlIGFycmF5IG9mIHJlc3QgY29tbWFuZCBsaW5lIHBhcmFtZXRlcnMuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmFkYkV4ZWNFbXUgPSBhc3luYyBmdW5jdGlvbiBhZGJFeGVjRW11IChjbWQpIHtcbiAgYXdhaXQgdGhpcy52ZXJpZnlFbXVsYXRvckNvbm5lY3RlZCgpO1xuICBhd2FpdCB0aGlzLnJlc2V0VGVsbmV0QXV0aFRva2VuKCk7XG4gIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ2VtdScsIC4uLmNtZF0pO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBnaXZlbiBhZGIgY29tbWFuZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjbWQgLSBUaGUgYXJyYXkgb2YgcmVzdCBjb21tYW5kIGxpbmUgcGFyYW1ldGVyc1xuICogICAgICAgICAgICAgICAgICAgICAgb3IgYSBzaW5nbGUgc3RyaW5nIHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gQWRkaXRpb25hbCBvcHRpb25zIG1hcHBpbmcuIFNlZVxuICogICAgICAgICAgICAgICAgICAgICAgICB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bS9ub2RlLXRlZW5fcHJvY2Vzc31cbiAqICAgICAgICAgICAgICAgICAgICAgICAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEByZXR1cm4ge3N0cmluZ30gLSBDb21tYW5kJ3Mgc3Rkb3V0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjb21tYW5kIHJldHVybmVkIG5vbi16ZXJvIGV4aXQgY29kZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuYWRiRXhlYyA9IGFzeW5jIGZ1bmN0aW9uIGFkYkV4ZWMgKGNtZCwgb3B0cyA9IHt9KSB7XG4gIGlmICghY21kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbmVlZCB0byBwYXNzIGluIGEgY29tbWFuZCB0byBhZGJFeGVjKCknKTtcbiAgfVxuXG4gIG9wdHMgPSBfLmNsb25lRGVlcChvcHRzKTtcbiAgLy8gc2V0dGluZyBkZWZhdWx0IHRpbWVvdXQgZm9yIGVhY2ggY29tbWFuZCB0byBwcmV2ZW50IGluZmluaXRlIHdhaXQuXG4gIG9wdHMudGltZW91dCA9IG9wdHMudGltZW91dCB8fCB0aGlzLmFkYkV4ZWNUaW1lb3V0IHx8IERFRkFVTFRfQURCX0VYRUNfVElNRU9VVDtcbiAgb3B0cy50aW1lb3V0Q2FwTmFtZSA9IG9wdHMudGltZW91dENhcE5hbWUgfHwgJ2FkYkV4ZWNUaW1lb3V0JzsgLy8gRm9yIGVycm9yIG1lc3NhZ2VcblxuICBjbWQgPSBfLmlzQXJyYXkoY21kKSA/IGNtZCA6IFtjbWRdO1xuXG4gIGxldCBhZGJSZXRyaWVkID0gZmFsc2U7XG4gIGNvbnN0IGV4ZWNGdW5jID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhcmdzID0gdGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLmNvbmNhdChjbWQpO1xuICAgICAgbG9nLmRlYnVnKGBSdW5uaW5nICcke3RoaXMuZXhlY3V0YWJsZS5wYXRofSAke3F1b3RlKGFyZ3MpfSdgKTtcbiAgICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWModGhpcy5leGVjdXRhYmxlLnBhdGgsIGFyZ3MsIG9wdHMpO1xuICAgICAgLy8gc29tZXRpbWVzIEFEQiBwcmludHMgb3V0IHdlaXJkIHN0ZG91dCB3YXJuaW5ncyB0aGF0IHdlIGRvbid0IHdhbnRcbiAgICAgIC8vIHRvIGluY2x1ZGUgaW4gYW55IG9mIHRoZSByZXNwb25zZSBkYXRhLCBzbyBsZXQncyBzdHJpcCBpdCBvdXRcbiAgICAgIHN0ZG91dCA9IHN0ZG91dC5yZXBsYWNlKExJTktFUl9XQVJOSU5HX1JFR0VYUCwgJycpLnRyaW0oKTtcbiAgICAgIHJldHVybiBzdGRvdXQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3QgZXJyVGV4dCA9IGAke2UubWVzc2FnZX0sICR7ZS5zdGRvdXR9LCAke2Uuc3RkZXJyfWA7XG4gICAgICBjb25zdCBwcm90b2NvbEZhdWx0RXJyb3IgPSBQUk9UT0NPTF9GQVVMVF9FUlJPUl9SRUdFWFAudGVzdChlcnJUZXh0KTtcbiAgICAgIGNvbnN0IGRldmljZU5vdEZvdW5kRXJyb3IgPSBERVZJQ0VfTk9UX0ZPVU5EX0VSUk9SX1JFR0VYUC50ZXN0KGVyclRleHQpO1xuICAgICAgY29uc3QgZGV2aWNlQ29ubmVjdGluZ0Vycm9yID0gREVWSUNFX0NPTk5FQ1RJTkdfRVJST1JfUkVHRVhQLnRlc3QoZXJyVGV4dCk7XG4gICAgICBpZiAocHJvdG9jb2xGYXVsdEVycm9yIHx8IGRldmljZU5vdEZvdW5kRXJyb3IgfHwgZGV2aWNlQ29ubmVjdGluZ0Vycm9yKSB7XG4gICAgICAgIGxvZy5pbmZvKGBFcnJvciBzZW5kaW5nIGNvbW1hbmQsIHJlY29ubmVjdGluZyBkZXZpY2UgYW5kIHJldHJ5aW5nOiAke2NtZH1gKTtcbiAgICAgICAgYXdhaXQgc2xlZXAoMTAwMCk7XG4gICAgICAgIGF3YWl0IHRoaXMuZ2V0RGV2aWNlc1dpdGhSZXRyeSgpO1xuXG4gICAgICAgIC8vIHRyeSBhZ2FpbiBvbmUgdGltZVxuICAgICAgICBpZiAoYWRiUmV0cmllZCkge1xuICAgICAgICAgIGFkYlJldHJpZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBhd2FpdCBleGVjRnVuYygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlLmNvZGUgPT09IDAgJiYgZS5zdGRvdXQpIHtcbiAgICAgICAgcmV0dXJuIGUuc3Rkb3V0LnJlcGxhY2UoTElOS0VSX1dBUk5JTkdfUkVHRVhQLCAnJykudHJpbSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc051bGwoZS5jb2RlKSkge1xuICAgICAgICBlLm1lc3NhZ2UgPSBgRXJyb3IgZXhlY3V0aW5nIGFkYkV4ZWMuIE9yaWdpbmFsIGVycm9yOiAnJHtlLm1lc3NhZ2V9Jy4gYCArXG4gICAgICAgICAgYFRyeSB0byBpbmNyZWFzZSB0aGUgJHtvcHRzLnRpbWVvdXR9bXMgYWRiIGV4ZWN1dGlvbiB0aW1lb3V0IHJlcHJlc2VudGVkIGJ5ICcke29wdHMudGltZW91dENhcE5hbWV9JyBjYXBhYmlsaXR5YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGUubWVzc2FnZSA9IGBFcnJvciBleGVjdXRpbmcgYWRiRXhlYy4gT3JpZ2luYWwgZXJyb3I6ICcke2UubWVzc2FnZX0nOyBgICtcbiAgICAgICAgICBgU3RkZXJyOiAnJHsoZS5zdGRlcnIgfHwgJycpLnRyaW0oKX0nOyBDb2RlOiAnJHtlLmNvZGV9J2A7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gYXdhaXQgZXhlY0Z1bmMoKTtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2hlbGxFeGVjT3B0aW9uc1xuICogQHByb3BlcnR5IHs/c3RyaW5nfSB0aW1lb3V0Q2FwTmFtZSBbYWRiRXhlY1RpbWVvdXRdIC0gdGhlIG5hbWUgb2YgdGhlIGNvcnJlc3BvbmRpbmcgQXBwaXVtJ3MgdGltZW91dCBjYXBhYmlsaXR5XG4gKiAodXNlZCBpbiB0aGUgZXJyb3IgbWVzc2FnZXMpLlxuICogQHByb3BlcnR5IHs/bnVtYmVyfSB0aW1lb3V0IFthZGJFeGVjVGltZW91dF0gLSBjb21tYW5kIGV4ZWN1dGlvbiB0aW1lb3V0LlxuICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gcHJpdmlsZWdlZCBbZmFsc3ldIC0gV2hldGhlciB0byBydW4gdGhlIGdpdmVuIGNvbW1hbmQgYXMgcm9vdC5cbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IGtlZXBQcml2aWxlZ2VkIFtmYWxzeV0gLSBXaGV0aGVyIHRvIGtlZXAgcm9vdCBtb2RlIGFmdGVyIGNvbW1hbmQgZXhlY3V0aW9uIGlzIGNvbXBsZXRlZC5cbiAqXG4gKiBBbGwgb3RoZXIgcHJvcGVydGllcyBhcmUgdGhlIHNhbWUgYXMgZm9yIGBleGVjYCBjYWxsIGZyb20ge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9hcHBpdW0vbm9kZS10ZWVuX3Byb2Nlc3N9XG4gKiBtb2R1bGVcbiAqL1xuXG4vKipcbiAqIEV4ZWN1dGUgdGhlIGdpdmVuIGNvbW1hbmQgdXNpbmcgX2FkYiBzaGVsbF8gcHJlZml4LlxuICpcbiAqIEBwYXJhbSB7IUFycmF5LjxzdHJpbmc+fHN0cmluZ30gY21kIC0gVGhlIGFycmF5IG9mIHJlc3QgY29tbWFuZCBsaW5lIHBhcmFtZXRlcnMgb3IgYSBzaW5nbGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgcGFyYW1ldGVyLlxuICogQHBhcmFtIHs/U2hlbGxFeGVjT3B0aW9uc30gb3B0cyBbe31dIC0gQWRkaXRpb25hbCBvcHRpb25zIG1hcHBpbmcuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IC0gQ29tbWFuZCdzIHN0ZG91dC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29tbWFuZCByZXR1cm5lZCBub24temVybyBleGl0IGNvZGUuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnNoZWxsID0gYXN5bmMgZnVuY3Rpb24gc2hlbGwgKGNtZCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBwcml2aWxlZ2VkLFxuICAgIGtlZXBQcml2aWxlZ2VkLFxuICB9ID0gb3B0cztcbiAgbGV0IHNob3VsZFJlc3RvcmVVc2VyID0gZmFsc2U7XG4gIGlmIChwcml2aWxlZ2VkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHNob3VsZFJlc3RvcmVVc2VyID0gIShhd2FpdCB0aGlzLmFkYkV4ZWMoWydyb290J10sIG9wdHMpKS5pbmNsdWRlcygnYWxyZWFkeSBydW5uaW5nIGFzIHJvb3QnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICghZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ2FkYmQgY2Fubm90IHJ1biBhcyByb290JykpIHtcbiAgICAgICAgLy8gRG8gbm90IHNob3cgdGhlIHdhcm5pbmcgZm9yIHJlYWwgZGV2aWNlcywgd2hlcmUgcm9vdCBpcyBsb2NrZWRcbiAgICAgICAgbG9nLndhcm4oYENhbm5vdCBydW4gYWRiZCBhcyByb290LiBPcmlnaW5hbCBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IGRpZENvbW1hbmRGYWlsID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmFkYkV4ZWMoXy5pc0FycmF5KGNtZCkgPyBbJ3NoZWxsJywgLi4uY21kXSA6IFsnc2hlbGwnLCBjbWRdLCBvcHRzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGRpZENvbW1hbmRGYWlsID0gdHJ1ZTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgaWYgKHByaXZpbGVnZWQgJiYgc2hvdWxkUmVzdG9yZVVzZXIgJiYgKCFrZWVwUHJpdmlsZWdlZCB8fCBkaWRDb21tYW5kRmFpbCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuYWRiRXhlYyhbJ3Vucm9vdCddLCBvcHRzKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cud2FybihgQ2Fubm90IHJ1biBhZGJkIGFzIG5vbi1yb290LiBPcmlnaW5hbCBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnN5c3RlbUNhbGxNZXRob2RzLmNyZWF0ZVN1YlByb2Nlc3MgPSBmdW5jdGlvbiBjcmVhdGVTdWJQcm9jZXNzIChhcmdzID0gW10pIHtcbiAgLy8gYWRkIHRoZSBkZWZhdWx0IGFyZ3VtZW50c1xuICBhcmdzID0gdGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLmNvbmNhdChhcmdzKTtcbiAgbG9nLmRlYnVnKGBDcmVhdGluZyBBREIgc3VicHJvY2VzcyB3aXRoIGFyZ3M6ICR7SlNPTi5zdHJpbmdpZnkoYXJncyl9YCk7XG4gIHJldHVybiBuZXcgU3ViUHJvY2Vzcyh0aGlzLmdldEFkYlBhdGgoKSwgYXJncyk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGFkYiBwb3J0LlxuICogQHRvZG8gY2FuIHByb2JhYmx5IGRlcHJlY2F0ZSB0aGlzIG5vdyB0aGF0IHRoZSBsb2dpYyBpcyBqdXN0IHRvIHJlYWQgdGhpcy5hZGJQb3J0XG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjdXJyZW50IGFkYiBwb3J0IG51bWJlci5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0QWRiU2VydmVyUG9ydCA9IGZ1bmN0aW9uIGdldEFkYlNlcnZlclBvcnQgKCkge1xuICByZXR1cm4gdGhpcy5hZGJQb3J0O1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBlbXVsYXRvciBwb3J0IGZyb20gX2FkYiBkZXZpdmVzXyBvdXRwdXQuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgY3VycmVudCBlbXVsYXRvciBwb3J0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGFyZSBubyBjb25uZWN0ZWQgZGV2aWNlcy5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0RW11bGF0b3JQb3J0ID0gYXN5bmMgZnVuY3Rpb24gZ2V0RW11bGF0b3JQb3J0ICgpIHtcbiAgbG9nLmRlYnVnKCdHZXR0aW5nIHJ1bm5pbmcgZW11bGF0b3IgcG9ydCcpO1xuICBpZiAodGhpcy5lbXVsYXRvclBvcnQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5lbXVsYXRvclBvcnQ7XG4gIH1cbiAgdHJ5IHtcbiAgICBsZXQgZGV2aWNlcyA9IGF3YWl0IHRoaXMuZ2V0Q29ubmVjdGVkRGV2aWNlcygpO1xuICAgIGxldCBwb3J0ID0gdGhpcy5nZXRQb3J0RnJvbUVtdWxhdG9yU3RyaW5nKGRldmljZXNbMF0udWRpZCk7XG4gICAgaWYgKHBvcnQpIHtcbiAgICAgIHJldHVybiBwb3J0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVtdWxhdG9yIHBvcnQgbm90IGZvdW5kYCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBkZXZpY2VzIGNvbm5lY3RlZC4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGVtdWxhdG9yIHBvcnQgYnkgcGFyc2luZyBlbXVsYXRvciBuYW1lIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW1TdHIgLSBFbXVsYXRvciBuYW1lIHN0cmluZy5cbiAqIEByZXR1cm4ge251bWJlcnxib29sZWFufSBFaXRoZXIgdGhlIGN1cnJlbnQgZW11bGF0b3IgcG9ydCBvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgIF9mYWxzZV8gaWYgcG9ydCBudW1iZXIgY2Fubm90IGJlIHBhcnNlZC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyA9IGZ1bmN0aW9uIGdldFBvcnRGcm9tRW11bGF0b3JTdHJpbmcgKGVtU3RyKSB7XG4gIGxldCBwb3J0UGF0dGVybiA9IC9lbXVsYXRvci0oXFxkKykvO1xuICBpZiAocG9ydFBhdHRlcm4udGVzdChlbVN0cikpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQocG9ydFBhdHRlcm4uZXhlYyhlbVN0cilbMV0sIDEwKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBsaXN0IG9mIGN1cnJlbnRseSBjb25uZWN0ZWQgZW11bGF0b3JzLlxuICpcbiAqIEByZXR1cm4ge0FycmF5LjxEZXZpY2U+fSBUaGUgbGlzdCBvZiBjb25uZWN0ZWQgZGV2aWNlcy5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0Q29ubmVjdGVkRW11bGF0b3JzID0gYXN5bmMgZnVuY3Rpb24gZ2V0Q29ubmVjdGVkRW11bGF0b3JzICgpIHtcbiAgbG9nLmRlYnVnKCdHZXR0aW5nIGNvbm5lY3RlZCBlbXVsYXRvcnMnKTtcbiAgdHJ5IHtcbiAgICBsZXQgZGV2aWNlcyA9IGF3YWl0IHRoaXMuZ2V0Q29ubmVjdGVkRGV2aWNlcygpO1xuICAgIGxldCBlbXVsYXRvcnMgPSBbXTtcbiAgICBmb3IgKGxldCBkZXZpY2Ugb2YgZGV2aWNlcykge1xuICAgICAgbGV0IHBvcnQgPSB0aGlzLmdldFBvcnRGcm9tRW11bGF0b3JTdHJpbmcoZGV2aWNlLnVkaWQpO1xuICAgICAgaWYgKHBvcnQpIHtcbiAgICAgICAgZGV2aWNlLnBvcnQgPSBwb3J0O1xuICAgICAgICBlbXVsYXRvcnMucHVzaChkZXZpY2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2cuZGVidWcoYCR7ZW11bGF0b3JzLmxlbmd0aH0gZW11bGF0b3IocykgY29ubmVjdGVkYCk7XG4gICAgcmV0dXJuIGVtdWxhdG9ycztcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZ2V0dGluZyBlbXVsYXRvcnMuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgX2VtdWxhdG9yUG9ydF8gcHJvcGVydHkgb2YgdGhlIGN1cnJlbnQgY2xhc3MuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGVtUG9ydCAtIFRoZSBlbXVsYXRvciBwb3J0IHRvIGJlIHNldC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuc2V0RW11bGF0b3JQb3J0ID0gZnVuY3Rpb24gc2V0RW11bGF0b3JQb3J0IChlbVBvcnQpIHtcbiAgdGhpcy5lbXVsYXRvclBvcnQgPSBlbVBvcnQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgaWRlbnRpZmllciBvZiB0aGUgY3VycmVudCBkZXZpY2UgKF90aGlzLmN1ckRldmljZUlkXykuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IC0gVGhlIGRldmljZSBpZGVudGlmaWVyLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5zZXREZXZpY2VJZCA9IGZ1bmN0aW9uIHNldERldmljZUlkIChkZXZpY2VJZCkge1xuICBsb2cuZGVidWcoYFNldHRpbmcgZGV2aWNlIGlkIHRvICR7ZGV2aWNlSWR9YCk7XG4gIHRoaXMuY3VyRGV2aWNlSWQgPSBkZXZpY2VJZDtcbiAgbGV0IGFyZ3NIYXNEZXZpY2UgPSB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3MuaW5kZXhPZignLXMnKTtcbiAgaWYgKGFyZ3NIYXNEZXZpY2UgIT09IC0xKSB7XG4gICAgLy8gcmVtb3ZlIHRoZSBvbGQgZGV2aWNlIGlkIGZyb20gdGhlIGFyZ3VtZW50c1xuICAgIHRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5zcGxpY2UoYXJnc0hhc0RldmljZSwgMik7XG4gIH1cbiAgdGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLnB1c2goJy1zJywgZGV2aWNlSWQpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHRoZSBjdXJyZW50IGRldmljZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtEZXZpY2V9IGRldmljZU9iaiAtIFRoZSBkZXZpY2Ugb2JqZWN0IHRvIGJlIHNldC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuc2V0RGV2aWNlID0gZnVuY3Rpb24gc2V0RGV2aWNlIChkZXZpY2VPYmopIHtcbiAgbGV0IGRldmljZUlkID0gZGV2aWNlT2JqLnVkaWQ7XG4gIGxldCBlbVBvcnQgPSB0aGlzLmdldFBvcnRGcm9tRW11bGF0b3JTdHJpbmcoZGV2aWNlSWQpO1xuICB0aGlzLnNldEVtdWxhdG9yUG9ydChlbVBvcnQpO1xuICB0aGlzLnNldERldmljZUlkKGRldmljZUlkKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBvYmplY3QgZm9yIHRoZSBjdXJyZW50bHkgcnVubmluZyBlbXVsYXRvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXZkTmFtZSAtIEVtdWxhdG9yIG5hbWUuXG4gKiBAcmV0dXJuIHs/RGV2aWNlfSBDdXJyZW50bHkgcnVubmluZyBlbXVsYXRvciBvciBfbnVsbF8uXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldFJ1bm5pbmdBVkQgPSBhc3luYyBmdW5jdGlvbiBnZXRSdW5uaW5nQVZEIChhdmROYW1lKSB7XG4gIGxvZy5kZWJ1ZyhgVHJ5aW5nIHRvIGZpbmQgJyR7YXZkTmFtZX0nIGVtdWxhdG9yYCk7XG4gIHRyeSB7XG4gICAgY29uc3QgZW11bGF0b3JzID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWRFbXVsYXRvcnMoKTtcbiAgICBmb3IgKGNvbnN0IGVtdWxhdG9yIG9mIGVtdWxhdG9ycykge1xuICAgICAgdGhpcy5zZXRFbXVsYXRvclBvcnQoZW11bGF0b3IucG9ydCk7XG4gICAgICBjb25zdCBydW5uaW5nQVZETmFtZSA9IGF3YWl0IHRoaXMuc2VuZFRlbG5ldENvbW1hbmQoJ2F2ZCBuYW1lJyk7XG4gICAgICBpZiAoXy50b0xvd2VyKGF2ZE5hbWUpID09PSBfLnRvTG93ZXIocnVubmluZ0FWRE5hbWUpKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhgRm91bmQgZW11bGF0b3IgJyR7YXZkTmFtZX0nIG9uIHBvcnQgJHtlbXVsYXRvci5wb3J0fWApO1xuICAgICAgICB0aGlzLnNldERldmljZUlkKGVtdWxhdG9yLnVkaWQpO1xuICAgICAgICByZXR1cm4gZW11bGF0b3I7XG4gICAgICB9XG4gICAgfVxuICAgIGxvZy5kZWJ1ZyhgRW11bGF0b3IgJyR7YXZkTmFtZX0nIG5vdCBydW5uaW5nYCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGdldHRpbmcgQVZELiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBvYmplY3QgZm9yIHRoZSBjdXJyZW50bHkgcnVubmluZyBlbXVsYXRvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXZkTmFtZSAtIEVtdWxhdG9yIG5hbWUuXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dE1zIFsyMDAwMF0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byB3YWl0IHVudGlsIGF0IGxlYXN0IG9uZSBydW5uaW5nIEFWRCBvYmplY3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGRldGVjdGVkLlxuICogQHJldHVybiB7P0RldmljZX0gQ3VycmVudGx5IHJ1bm5pbmcgZW11bGF0b3Igb3IgX251bGxfLlxuICogQHRocm93cyB7RXJyb3J9IElmIG5vIGRldmljZSBoYXMgYmVlbiBkZXRlY3RlZCB3aXRoaW4gdGhlIHRpbWVvdXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldFJ1bm5pbmdBVkRXaXRoUmV0cnkgPSBhc3luYyBmdW5jdGlvbiBnZXRSdW5uaW5nQVZEV2l0aFJldHJ5IChhdmROYW1lLCB0aW1lb3V0TXMgPSAyMDAwMCkge1xuICBsZXQgcnVubmluZ0F2ZDtcbiAgdHJ5IHtcbiAgICBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJ1bm5pbmdBdmQgPSBhd2FpdCB0aGlzLmdldFJ1bm5pbmdBVkQoYXZkTmFtZS5yZXBsYWNlKCdAJywgJycpKTtcbiAgICAgICAgcmV0dXJuIHJ1bm5pbmdBdmQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhlLm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgd2FpdE1zOiB0aW1lb3V0TXMsXG4gICAgICBpbnRlcnZhbE1zOiAxMDAwLFxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBnZXR0aW5nIEFWRCB3aXRoIHJldHJ5LiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbiAgcmV0dXJuIHJ1bm5pbmdBdmQ7XG59O1xuXG4vKipcbiAqIFNodXRkb3duIGFsbCBydW5uaW5nIGVtdWxhdG9ycyBieSBraWxsaW5nIHRoZWlyIHByb2Nlc3Nlcy5cbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYga2lsbGluZyB0b29sIHJldHVybmVkIG5vbi16ZXJvIHJldHVybiBjb2RlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5raWxsQWxsRW11bGF0b3JzID0gYXN5bmMgZnVuY3Rpb24ga2lsbEFsbEVtdWxhdG9ycyAoKSB7XG4gIGxldCBjbWQsIGFyZ3M7XG4gIGlmIChzeXN0ZW0uaXNXaW5kb3dzKCkpIHtcbiAgICBjbWQgPSAnVEFTS0tJTEwnO1xuICAgIGFyZ3MgPSBbJ1RBU0tLSUxMJywgJy9JTScsICdlbXVsYXRvci5leGUnXTtcbiAgfSBlbHNlIHtcbiAgICBjbWQgPSAnL3Vzci9iaW4va2lsbGFsbCc7XG4gICAgYXJncyA9IFsnLW0nLCAnZW11bGF0b3IqJ107XG4gIH1cbiAgdHJ5IHtcbiAgICBhd2FpdCBleGVjKGNtZCwgYXJncyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGtpbGxpbmcgZW11bGF0b3JzLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogS2lsbCBlbXVsYXRvciB3aXRoIHRoZSBnaXZlbiBuYW1lLiBObyBlcnJvclxuICogaXMgdGhyb3duIGlzIGdpdmVuIGF2ZCBkb2VzIG5vdCBleGlzdC9pcyBub3QgcnVubmluZy5cbiAqXG4gKiBAcGFyYW0gez9zdHJpbmd9IGF2ZE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZW11bGF0b3IgdG8gYmUga2lsbGVkLiBJZiBlbXB0eSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBjdXJyZW50IGVtdWxhdG9yIHdpbGwgYmUga2lsbGVkLlxuICogQHBhcmFtIHs/bnVtYmVyfSB0aW1lb3V0IFs2MDAwMF0gLSBUaGUgYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBiZWZvcmUgdGhyb3dpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW4gZXhjZXB0aW9uIGFib3V0IHVuc3VjY2Vzc2Z1bCBraWxsaW5nXG4gKiBAcmV0dXJuIHtib29sZWFufSAtIFRydWUgaWYgdGhlIGVtdWxhdG9yIHdhcyBraWxsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGVyZSB3YXMgYSBmYWlsdXJlIGJ5IGtpbGxpbmcgdGhlIGVtdWxhdG9yXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmtpbGxFbXVsYXRvciA9IGFzeW5jIGZ1bmN0aW9uIGtpbGxFbXVsYXRvciAoYXZkTmFtZSA9IG51bGwsIHRpbWVvdXQgPSA2MDAwMCkge1xuICBpZiAodXRpbC5oYXNWYWx1ZShhdmROYW1lKSkge1xuICAgIGxvZy5kZWJ1ZyhgS2lsbGluZyBhdmQgJyR7YXZkTmFtZX0nYCk7XG4gICAgY29uc3QgZGV2aWNlID0gYXdhaXQgdGhpcy5nZXRSdW5uaW5nQVZEKGF2ZE5hbWUpO1xuICAgIGlmICghZGV2aWNlKSB7XG4gICAgICBsb2cuaW5mbyhgTm8gYXZkIHdpdGggbmFtZSAnJHthdmROYW1lfScgcnVubmluZy4gU2tpcHBpbmcga2lsbCBzdGVwLmApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBraWxsaW5nIHRoZSBjdXJyZW50IGF2ZFxuICAgIGxvZy5kZWJ1ZyhgS2lsbGluZyBhdmQgd2l0aCBpZCAnJHt0aGlzLmN1ckRldmljZUlkfSdgKTtcbiAgICBpZiAoIWF3YWl0IHRoaXMuaXNFbXVsYXRvckNvbm5lY3RlZCgpKSB7XG4gICAgICBsb2cuZGVidWcoYEVtdWxhdG9yIHdpdGggaWQgJyR7dGhpcy5jdXJEZXZpY2VJZH0nIG5vdCBjb25uZWN0ZWQuIFNraXBwaW5nIGtpbGwgc3RlcGApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBhd2FpdCB0aGlzLmFkYkV4ZWMoWydlbXUnLCAna2lsbCddKTtcbiAgbG9nLmRlYnVnKGBXYWl0aW5nIHVwIHRvICR7dGltZW91dH1tcyB1bnRpbCB0aGUgZW11bGF0b3IgJyR7YXZkTmFtZSA/IGF2ZE5hbWUgOiB0aGlzLmN1ckRldmljZUlkfScgaXMga2lsbGVkYCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgd2FpdEZvckNvbmRpdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXRpbC5oYXNWYWx1ZShhdmROYW1lKVxuICAgICAgICAgID8gIWF3YWl0IHRoaXMuZ2V0UnVubmluZ0FWRChhdmROYW1lKVxuICAgICAgICAgIDogIWF3YWl0IHRoaXMuaXNFbXVsYXRvckNvbm5lY3RlZCgpO1xuICAgICAgfSBjYXRjaCAoaWduKSB7fVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIHtcbiAgICAgIHdhaXRNczogdGltZW91dCxcbiAgICAgIGludGVydmFsTXM6IDIwMDAsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBlbXVsYXRvciAnJHthdmROYW1lID8gYXZkTmFtZSA6IHRoaXMuY3VyRGV2aWNlSWR9JyBpcyBzdGlsbCBydW5uaW5nIGFmdGVyIGJlaW5nIGtpbGxlZCAke3RpbWVvdXR9bXMgYWdvYCk7XG4gIH1cbiAgbG9nLmluZm8oYFN1Y2Nlc3NmdWxseSBraWxsZWQgdGhlICcke2F2ZE5hbWUgPyBhdmROYW1lIDogdGhpcy5jdXJEZXZpY2VJZH0nIGVtdWxhdG9yYCk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBTdGFydCBhbiBlbXVsYXRvciB3aXRoIGdpdmVuIHBhcmFtZXRlcnMgYW5kIHdhaXQgdW50aWwgaXQgaXMgZnVsbCBzdGFydGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdmROYW1lIC0gVGhlIG5hbWUgb2YgYW4gZXhpc3RpbmcgZW11bGF0b3IuXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fHN0cmluZ30gYXZkQXJncyAtIEFkZGl0aW9uYWwgZW11bGF0b3IgY29tbWFuZCBsaW5lIGFyZ3VtZW50LlxuICogQHBhcmFtIHs/c3RyaW5nfSBsYW5ndWFnZSAtIEVtdWxhdG9yIHN5c3RlbSBsYW5ndWFnZS5cbiAqIEBwYXJhbSB7P2NvdW50cnl9IGNvdW50cnkgLSBFbXVsYXRvciBzeXN0ZW0gY291bnRyeS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBhdmRMYXVuY2hUaW1lb3V0IFs2MDAwMF0gLSBFbXVsYXRvciBzdGFydHVwIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHJldHJ5VGltZXMgWzFdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHN0YXJ0dXAgcmV0cmllcy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZW11bGF0b3IgZmFpbHMgdG8gc3RhcnQgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5sYXVuY2hBVkQgPSBhc3luYyBmdW5jdGlvbiBsYXVuY2hBVkQgKGF2ZE5hbWUsIGF2ZEFyZ3MsIGxhbmd1YWdlLCBjb3VudHJ5LFxuICBhdmRMYXVuY2hUaW1lb3V0ID0gNjAwMDAsIGF2ZFJlYWR5VGltZW91dCA9IDYwMDAwLCByZXRyeVRpbWVzID0gMSkge1xuICBsb2cuZGVidWcoYExhdW5jaGluZyBFbXVsYXRvciB3aXRoIEFWRCAke2F2ZE5hbWV9LCBsYXVuY2hUaW1lb3V0IGAgK1xuICAgICAgICAgICAgYCR7YXZkTGF1bmNoVGltZW91dH1tcyBhbmQgcmVhZHlUaW1lb3V0ICR7YXZkUmVhZHlUaW1lb3V0fW1zYCk7XG4gIGxldCBlbXVsYXRvckJpbmFyeVBhdGggPSBhd2FpdCB0aGlzLmdldFNka0JpbmFyeVBhdGgoJ2VtdWxhdG9yJyk7XG4gIGlmIChhdmROYW1lWzBdID09PSAnQCcpIHtcbiAgICBhdmROYW1lID0gYXZkTmFtZS5zdWJzdHIoMSk7XG4gIH1cbiAgYXdhaXQgdGhpcy5jaGVja0F2ZEV4aXN0KGF2ZE5hbWUpO1xuICBsZXQgbGF1bmNoQXJncyA9IFsnLWF2ZCcsIGF2ZE5hbWVdO1xuICBpZiAoXy5pc1N0cmluZyhsYW5ndWFnZSkpIHtcbiAgICBsb2cuZGVidWcoYFNldHRpbmcgQW5kcm9pZCBEZXZpY2UgTGFuZ3VhZ2UgdG8gJHtsYW5ndWFnZX1gKTtcbiAgICBsYXVuY2hBcmdzLnB1c2goJy1wcm9wJywgYHBlcnNpc3Quc3lzLmxhbmd1YWdlPSR7bGFuZ3VhZ2UudG9Mb3dlckNhc2UoKX1gKTtcbiAgfVxuICBpZiAoXy5pc1N0cmluZyhjb3VudHJ5KSkge1xuICAgIGxvZy5kZWJ1ZyhgU2V0dGluZyBBbmRyb2lkIERldmljZSBDb3VudHJ5IHRvICR7Y291bnRyeX1gKTtcbiAgICBsYXVuY2hBcmdzLnB1c2goJy1wcm9wJywgYHBlcnNpc3Quc3lzLmNvdW50cnk9JHtjb3VudHJ5LnRvVXBwZXJDYXNlKCl9YCk7XG4gIH1cbiAgbGV0IGxvY2FsZTtcbiAgaWYgKF8uaXNTdHJpbmcobGFuZ3VhZ2UpICYmIF8uaXNTdHJpbmcoY291bnRyeSkpIHtcbiAgICBsb2NhbGUgPSBsYW5ndWFnZS50b0xvd2VyQ2FzZSgpICsgJy0nICsgY291bnRyeS50b1VwcGVyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcobGFuZ3VhZ2UpKSB7XG4gICAgbG9jYWxlID0gbGFuZ3VhZ2UudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGNvdW50cnkpKSB7XG4gICAgbG9jYWxlID0gY291bnRyeTtcbiAgfVxuICBpZiAoXy5pc1N0cmluZyhsb2NhbGUpKSB7XG4gICAgbG9nLmRlYnVnKGBTZXR0aW5nIEFuZHJvaWQgRGV2aWNlIExvY2FsZSB0byAke2xvY2FsZX1gKTtcbiAgICBsYXVuY2hBcmdzLnB1c2goJy1wcm9wJywgYHBlcnNpc3Quc3lzLmxvY2FsZT0ke2xvY2FsZX1gKTtcbiAgfVxuICBpZiAoIV8uaXNFbXB0eShhdmRBcmdzKSkge1xuICAgIGxhdW5jaEFyZ3MucHVzaCguLi4oXy5pc0FycmF5KGF2ZEFyZ3MpID8gYXZkQXJncyA6IGF2ZEFyZ3Muc3BsaXQoJyAnKSkpO1xuICB9XG4gIGxvZy5kZWJ1ZyhgUnVubmluZyAnJHtlbXVsYXRvckJpbmFyeVBhdGh9JyB3aXRoIGFyZ3M6ICR7SlNPTi5zdHJpbmdpZnkobGF1bmNoQXJncyl9YCk7XG4gIGxldCBwcm9jID0gbmV3IFN1YlByb2Nlc3MoZW11bGF0b3JCaW5hcnlQYXRoLCBsYXVuY2hBcmdzKTtcbiAgYXdhaXQgcHJvYy5zdGFydCgwKTtcbiAgcHJvYy5vbignb3V0cHV0JywgKHN0ZG91dCwgc3RkZXJyKSA9PiB7XG4gICAgZm9yIChsZXQgbGluZSBvZiAoc3Rkb3V0IHx8IHN0ZGVyciB8fCAnJykuc3BsaXQoJ1xcbicpLmZpbHRlcihCb29sZWFuKSkge1xuICAgICAgbG9nLmluZm8oYFtBVkQgT1VUUFVUXSAke2xpbmV9YCk7XG4gICAgfVxuICB9KTtcbiAgcHJvYy5vbignZGllJywgKGNvZGUsIHNpZ25hbCkgPT4ge1xuICAgIGxvZy53YXJuKGBFbXVsYXRvciBhdmQgJHthdmROYW1lfSBleGl0ZWQgd2l0aCBjb2RlICR7Y29kZX0ke3NpZ25hbCA/IGAsIHNpZ25hbCAke3NpZ25hbH1gIDogJyd9YCk7XG4gIH0pO1xuICBhd2FpdCByZXRyeShyZXRyeVRpbWVzLCBhc3luYyAoKSA9PiBhd2FpdCB0aGlzLmdldFJ1bm5pbmdBVkRXaXRoUmV0cnkoYXZkTmFtZSwgYXZkTGF1bmNoVGltZW91dCkpO1xuICBhd2FpdCB0aGlzLndhaXRGb3JFbXVsYXRvclJlYWR5KGF2ZFJlYWR5VGltZW91dCk7XG4gIHJldHVybiBwcm9jO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBREJWZXJzaW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdmVyc2lvblN0cmluZyAtIEFEQiB2ZXJzaW9uIGFzIGEgc3RyaW5nLlxuICogQHByb3BlcnR5IHtmbG9hdH0gdmVyc2lvbkZsb2F0IC0gVmVyc2lvbiBudW1iZXIgYXMgZmxvYXQgdmFsdWUgKHVzZWZ1bCBmb3IgY29tcGFyaXNvbikuXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWFqb3IgLSBNYWpvciB2ZXJzaW9uIG51bWJlci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5vciAtIE1pbm9yIHZlcnNpb24gbnVtYmVyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBhdGNoIC0gUGF0Y2ggdmVyc2lvbiBudW1iZXIuXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIGFkYiB2ZXJzaW9uLiBUaGUgcmVzdWx0IG9mIHRoaXMgbWV0aG9kIGlzIGNhY2hlZC5cbiAqXG4gKiBAcmV0dXJuIHtBREJWZXJzaW9ufSBUaGUgY3VycmVudCBhZGIgdmVyc2lvbi5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpdCBpcyBub3QgcG9zc2libGUgdG8gcGFyc2UgYWRiIHZlcnNpb24uXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldEFkYlZlcnNpb24gPSBfLm1lbW9pemUoYXN5bmMgZnVuY3Rpb24gZ2V0QWRiVmVyc2lvbiAoKSB7XG4gIHRyeSB7XG4gICAgbGV0IGFkYlZlcnNpb24gPSAoYXdhaXQgdGhpcy5hZGJFeGVjKCd2ZXJzaW9uJykpXG4gICAgICAucmVwbGFjZSgvQW5kcm9pZFxcc0RlYnVnXFxzQnJpZGdlXFxzdmVyc2lvblxccyhbXFxkLl0qKVtcXHNcXHctXSovLCAnJDEnKTtcbiAgICBsZXQgcGFydHMgPSBhZGJWZXJzaW9uLnNwbGl0KCcuJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlcnNpb25TdHJpbmc6IGFkYlZlcnNpb24sXG4gICAgICB2ZXJzaW9uRmxvYXQ6IHBhcnNlRmxvYXQoYWRiVmVyc2lvbiksXG4gICAgICBtYWpvcjogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcbiAgICAgIG1pbm9yOiBwYXJzZUludChwYXJ0c1sxXSwgMTApLFxuICAgICAgcGF0Y2g6IHBhcnRzWzJdID8gcGFyc2VJbnQocGFydHNbMl0sIDEwKSA6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBnZXR0aW5nIGFkYiB2ZXJzaW9uLiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfSc7IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYFN0ZGVycjogJyR7KGUuc3RkZXJyIHx8ICcnKS50cmltKCl9JzsgQ29kZTogJyR7ZS5jb2RlfSdgKTtcbiAgfVxufSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgZ2l2ZW4gZW11bGF0b3IgZXhpc3RzIGluIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSBhdmRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdmROYW1lIC0gVGhlIG5hbWUgb2YgZW11bGF0b3IgdG8gdmVyaWZ5IGZvciBleGlzdGVuY2UuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGVtdWxhdG9yIHdpdGggZ2l2ZW4gbmFtZSBkb2VzIG5vdCBleGlzdC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuY2hlY2tBdmRFeGlzdCA9IGFzeW5jIGZ1bmN0aW9uIGNoZWNrQXZkRXhpc3QgKGF2ZE5hbWUpIHtcbiAgbGV0IGNtZCwgcmVzdWx0O1xuICB0cnkge1xuICAgIGNtZCA9IGF3YWl0IHRoaXMuZ2V0U2RrQmluYXJ5UGF0aCgnZW11bGF0b3InKTtcbiAgICByZXN1bHQgPSBhd2FpdCBleGVjKGNtZCwgWyctbGlzdC1hdmRzJ10pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbGV0IHVua25vd25PcHRpb25FcnJvciA9IG5ldyBSZWdFeHAoJ3Vua25vd24gb3B0aW9uOiAtbGlzdC1hdmRzJywgJ2knKS50ZXN0KGUuc3RkZXJyKTtcbiAgICBpZiAoIXVua25vd25PcHRpb25FcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBleGVjdXRpbmcgY2hlY2tBdmRFeGlzdC4gT3JpZ2luYWwgZXJyb3I6ICcke2UubWVzc2FnZX0nOyBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgU3RkZXJyOiAnJHsoZS5zdGRlcnIgfHwgJycpLnRyaW0oKX0nOyBDb2RlOiAnJHtlLmNvZGV9J2ApO1xuXG4gICAgfVxuICAgIGNvbnN0IHNka1ZlcnNpb24gPSBhd2FpdCBnZXRTZGtUb29sc1ZlcnNpb24oKTtcbiAgICBsZXQgYmluYXJ5TmFtZSA9ICdhbmRyb2lkJztcbiAgICBpZiAoc2RrVmVyc2lvbikge1xuICAgICAgaWYgKHNka1ZlcnNpb24ubWFqb3IgPj0gMjUpIHtcbiAgICAgICAgYmluYXJ5TmFtZSA9ICdhdmRtYW5hZ2VyJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9nLndhcm4oYERlZmF1bHRpbmcgYmluYXJ5IG5hbWUgdG8gJyR7YmluYXJ5TmFtZX0nLCBiZWNhdXNlIFNESyB2ZXJzaW9uIGNhbm5vdCBiZSBwYXJzZWRgKTtcbiAgICB9XG4gICAgLy8gSWYgLWxpc3QtYXZkcyBvcHRpb24gaXMgbm90IGF2YWlsYWJsZSwgdXNlIGFuZHJvaWQgY29tbWFuZCBhcyBhbiBhbHRlcm5hdGl2ZVxuICAgIGNtZCA9IGF3YWl0IHRoaXMuZ2V0U2RrQmluYXJ5UGF0aChiaW5hcnlOYW1lKTtcbiAgICByZXN1bHQgPSBhd2FpdCBleGVjKGNtZCwgWydsaXN0JywgJ2F2ZCcsICctYyddKTtcbiAgfVxuICBpZiAocmVzdWx0LnN0ZG91dC5pbmRleE9mKGF2ZE5hbWUpID09PSAtMSkge1xuICAgIGxldCBleGlzdGluZ3MgPSBgKCR7cmVzdWx0LnN0ZG91dC50cmltKCkucmVwbGFjZSgvW1xcbl0vZywgJyksICgnKX0pYDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEF2ZCAnJHthdmROYW1lfScgaXMgbm90IGF2YWlsYWJsZS4gcGxlYXNlIHNlbGVjdCB5b3VyIGF2ZCBuYW1lIGZyb20gb25lIG9mIHRoZXNlOiAnJHtleGlzdGluZ3N9J2ApO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBjdXJyZW50IGVtdWxhdG9yIGlzIHJlYWR5IHRvIGFjY2VwdCBmdXJ0aGVyIGNvbW1hbmRzIChib290aW5nIGNvbXBsZXRlZCkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRNcyBbMjAwMDBdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBlbXVsYXRvciBpcyBub3QgcmVhZHkgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy53YWl0Rm9yRW11bGF0b3JSZWFkeSA9IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JFbXVsYXRvclJlYWR5ICh0aW1lb3V0TXMgPSAyMDAwMCkge1xuICB0cnkge1xuICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5zaGVsbChbJ2dldHByb3AnLCAnaW5pdC5zdmMuYm9vdGFuaW0nXSkpLmluY2x1ZGVzKCdzdG9wcGVkJykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZXRpbWVzIHRoZSBwYWNrYWdlIG1hbmFnZXIgc2VydmljZSBtaWdodCBzdGlsbCBiZWluZyBpbml0aWFsaXplZFxuICAgICAgICAvLyBvbiBzbG93IHN5c3RlbXMgZXZlbiBhZnRlciBlbXVsYXRvciBib290aW5nIGlzIGNvbXBsZXRlZC5cbiAgICAgICAgLy8gVGhlIHVzdWFsIG91dHB1dCBvZiBgcG0gZ2V0LWluc3RhbGwtbG9jYXRpb25gIGNvbW1hbmQgbG9va3MgbGlrZSBgMFthdXRvXWBcbiAgICAgICAgcmV0dXJuIC9cXGQrXFxbXFx3K1xcXS8udGVzdChhd2FpdCB0aGlzLnNoZWxsKFsncG0nLCAnZ2V0LWluc3RhbGwtbG9jYXRpb24nXSkpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhgV2FpdGluZyBmb3IgZW11bGF0b3Igc3RhcnR1cC4gSW50ZXJtZWRpYXRlIGVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgd2FpdE1zOiB0aW1lb3V0TXMsXG4gICAgICBpbnRlcnZhbE1zOiAzMDAwLFxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFbXVsYXRvciBpcyBub3QgcmVhZHkgd2l0aGluICR7dGltZW91dE1zfW1zYCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGN1cnJlbnQgZGV2aWNlIGlzIHJlYWR5IHRvIGFjY2VwdCBmdXJ0aGVyIGNvbW1hbmRzIChib290aW5nIGNvbXBsZXRlZCkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGFwcERldmljZVJlYWR5VGltZW91dCBbMzBdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNlY29uZHMgdG8gd2FpdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZGV2aWNlIGlzIG5vdCByZWFkeSB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLndhaXRGb3JEZXZpY2UgPSBhc3luYyBmdW5jdGlvbiB3YWl0Rm9yRGV2aWNlIChhcHBEZXZpY2VSZWFkeVRpbWVvdXQgPSAzMCkge1xuICB0aGlzLmFwcERldmljZVJlYWR5VGltZW91dCA9IGFwcERldmljZVJlYWR5VGltZW91dDtcbiAgY29uc3QgcmV0cmllcyA9IDM7XG4gIGNvbnN0IHRpbWVvdXQgPSBwYXJzZUludCh0aGlzLmFwcERldmljZVJlYWR5VGltZW91dCwgMTApIC8gcmV0cmllcyAqIDEwMDA7XG4gIGF3YWl0IHJldHJ5KHJldHJpZXMsIGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5hZGJFeGVjKCd3YWl0LWZvci1kZXZpY2UnLCB7dGltZW91dH0pO1xuICAgICAgYXdhaXQgdGhpcy5waW5nKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgYXdhaXQgdGhpcy5yZXN0YXJ0QWRiKCk7XG4gICAgICBhd2FpdCB0aGlzLmdldENvbm5lY3RlZERldmljZXMoKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3Igd2FpdGluZyBmb3IgdGhlIGRldmljZSB0byBiZSBhdmFpbGFibGUuIE9yaWdpbmFsIGVycm9yOiAnJHtlLm1lc3NhZ2V9J2ApO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlYm9vdCB0aGUgY3VycmVudCBkZXZpY2UgYW5kIHdhaXQgdW50aWwgaXQgaXMgY29tcGxldGVkLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSByZXRyaWVzIFtERUZBVUxUX0FEQl9SRUJPT1RfUkVUUklFU10gLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmVib290IHJldHJpZXMuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGRldmljZSBmYWlsZWQgdG8gcmVib290IGFuZCBudW1iZXIgb2YgcmV0cmllcyBpcyBleGNlZWRlZC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMucmVib290ID0gYXN5bmMgZnVuY3Rpb24gcmVib290IChyZXRyaWVzID0gREVGQVVMVF9BREJfUkVCT09UX1JFVFJJRVMpIHtcbiAgYXdhaXQgdGhpcy5zaGVsbChbJ3N0b3AnXSwge1xuICAgIHByaXZpbGVnZWQ6IHRydWUsXG4gIH0pO1xuICBhd2FpdCBCLmRlbGF5KDIwMDApOyAvLyBsZXQgdGhlIGVtdSBmaW5pc2ggc3RvcHBpbmc7XG4gIGF3YWl0IHRoaXMuc2V0RGV2aWNlUHJvcGVydHkoJ3N5cy5ib290X2NvbXBsZXRlZCcsIDApO1xuICBhd2FpdCB0aGlzLnNoZWxsKFsnc3RhcnQnXSwge1xuICAgIHByaXZpbGVnZWQ6IHRydWUsXG4gIH0pO1xuICBjb25zdCBzdGFydGVkID0gcHJvY2Vzcy5ocnRpbWUoKTtcbiAgYXdhaXQgcmV0cnlJbnRlcnZhbChyZXRyaWVzLCAxMDAwLCBhc3luYyAoKSA9PiB7XG4gICAgaWYgKChhd2FpdCB0aGlzLmdldERldmljZVByb3BlcnR5KCdzeXMuYm9vdF9jb21wbGV0ZWQnKSkgPT09ICcxJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSBzdGFjayB0cmFjZSwgc28gbm8gbG9nLmVycm9yQW5kVGhyb3dcbiAgICBjb25zdCBtc2cgPSBgUmVib290IGlzIG5vdCBjb21wbGV0ZWQgYWZ0ZXIgJHtwcm9jZXNzLmhydGltZShzdGFydGVkKVswXX1zYDtcbiAgICBsb2cuZGVidWcobXNnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFN3aXRjaCBhZGIgc2VydmVyIHRvIHJvb3QgbW9kZS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIG9mIHRoZSBzd2l0Y2ggd2FzIHN1Y2Nlc3NmdWwgb3IgZmFsc2VcbiAqICAgICAgICAgICAgICAgICAgIGlmIHRoZSBzd2l0Y2ggZmFpbGVkLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5yb290ID0gYXN5bmMgZnVuY3Rpb24gcm9vdCAoKSB7XG4gIHRyeSB7XG4gICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyh0aGlzLmV4ZWN1dGFibGUucGF0aCwgWydyb290J10pO1xuXG4gICAgLy8gb24gcmVhbCBkZXZpY2VzIGluIHNvbWUgc2l0dWF0aW9ucyB3ZSBnZXQgYW4gZXJyb3IgaW4gdGhlIHN0ZG91dFxuICAgIGlmIChzdGRvdXQgJiYgc3Rkb3V0LmluZGV4T2YoJ2FkYmQgY2Fubm90IHJ1biBhcyByb290JykgIT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3Ioc3Rkb3V0LnRyaW0oKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZy53YXJuKGBVbmFibGUgdG8gcm9vdCBhZGIgZGFlbW9uOiAnJHtlcnIubWVzc2FnZX0nLiBDb250aW51aW5nYCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFN3aXRjaCBhZGIgc2VydmVyIHRvIG5vbi1yb290IG1vZGUuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBvZiB0aGUgc3dpdGNoIHdhcyBzdWNjZXNzZnVsIG9yIGZhbHNlXG4gKiAgICAgICAgICAgICAgICAgICBpZiB0aGUgc3dpdGNoIGZhaWxlZC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMudW5yb290ID0gYXN5bmMgZnVuY3Rpb24gdW5yb290ICgpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBleGVjKHRoaXMuZXhlY3V0YWJsZS5wYXRoLCBbJ3Vucm9vdCddKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLndhcm4oYFVuYWJsZSB0byB1bnJvb3QgYWRiIGRhZW1vbjogJyR7ZXJyLm1lc3NhZ2V9Jy4gQ29udGludWluZ2ApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgY3VycmVudCB1c2VyIGlzIHJvb3RcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB1c2VyIGlzIHJvb3RcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaWRlbnRpZnlpbmdcbiAqIHRoZSB1c2VyLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5pc1Jvb3QgPSBhc3luYyBmdW5jdGlvbiBpc1Jvb3QgKCkge1xuICByZXR1cm4gKGF3YWl0IHRoaXMuc2hlbGwoWyd3aG9hbWknXSkpLnRyaW0oKSA9PT0gJ3Jvb3QnO1xufTtcblxuLyoqXG4gKiBWZXJpZnkgd2hldGhlciBhIHJlbW90ZSBwYXRoIGV4aXN0cyBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcmVtb3RlIHBhdGggdG8gdmVyaWZ5LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZ2l2ZW4gcGF0aCBleGlzdHMgb24gdGhlIGRldmljZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZmlsZUV4aXN0cyA9IGFzeW5jIGZ1bmN0aW9uIGZpbGVFeGlzdHMgKHJlbW90ZVBhdGgpIHtcbiAgbGV0IGZpbGVzID0gYXdhaXQgdGhpcy5scyhyZW1vdGVQYXRoKTtcbiAgcmV0dXJuIGZpbGVzLmxlbmd0aCA+IDA7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgb3V0cHV0IG9mIF9sc18gY29tbWFuZCBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcmVtb3RlIHBhdGggKHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgX2xzXyBjb21tYW5kKS5cbiAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IG9wdHMgW1tdXSAtIEFkZGl0aW9uYWwgX2xzXyBvcHRpb25zLlxuICogQHJldHVybiB7QXJyYXkuPFN0cmluZz59IFRoZSBfbHNfIG91dHB1dCBhcyBhbiBhcnJheSBvZiBzcGxpdCBsaW5lcy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBBbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZCBvZiB0aGUgZ2l2ZW4gX3JlbW90ZVBhdGhfXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgZG9lcyBub3QgZXhpc3QuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmxzID0gYXN5bmMgZnVuY3Rpb24gbHMgKHJlbW90ZVBhdGgsIG9wdHMgPSBbXSkge1xuICB0cnkge1xuICAgIGxldCBhcmdzID0gWydscycsIC4uLm9wdHMsIHJlbW90ZVBhdGhdO1xuICAgIGxldCBzdGRvdXQgPSBhd2FpdCB0aGlzLnNoZWxsKGFyZ3MpO1xuICAgIGxldCBsaW5lcyA9IHN0ZG91dC5zcGxpdCgnXFxuJyk7XG4gICAgcmV0dXJuIGxpbmVzLm1hcCgobCkgPT4gbC50cmltKCkpXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAuZmlsdGVyKChsKSA9PiBsLmluZGV4T2YoJ05vIHN1Y2ggZmlsZScpID09PSAtMSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIubWVzc2FnZS5pbmRleE9mKCdObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5JykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIHNpemUgb2YgdGhlIHBhcnRpY3VsYXIgZmlsZSBsb2NhdGVkIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSByZW1vdGUgcGF0aCB0byB0aGUgZmlsZS5cbiAqIEByZXR1cm4ge251bWJlcn0gRmlsZSBzaXplIGluIGJ5dGVzLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBnZXR0aW5nIHRoZSBzaXplIG9mIHRoZSBnaXZlbiBmaWxlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5maWxlU2l6ZSA9IGFzeW5jIGZ1bmN0aW9uIGZpbGVTaXplIChyZW1vdGVQYXRoKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZmlsZXMgPSBhd2FpdCB0aGlzLmxzKHJlbW90ZVBhdGgsIFsnLWxhJ10pO1xuICAgIGlmIChmaWxlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVtb3RlIHBhdGggaXMgbm90IGEgZmlsZWApO1xuICAgIH1cbiAgICAvLyBodHRwczovL3JlZ2V4MTAxLmNvbS9yL2ZPczRQNC84XG4gICAgY29uc3QgbWF0Y2ggPSAvW3J3eHNTdFRcXC0rXXsxMH1bXFxzXFxkXSpcXHNbXlxcc10rXFxzK1teXFxzXStcXHMrKFxcZCspLy5leGVjKGZpbGVzWzBdKTtcbiAgICBpZiAoIW1hdGNoIHx8IF8uaXNOYU4ocGFyc2VJbnQobWF0Y2hbMV0sIDEwKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHBhcnNlIHNpemUgZnJvbSBsaXN0IG91dHB1dDogJyR7ZmlsZXNbMF19J2ApO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZ2V0IGZpbGUgc2l6ZSBmb3IgJyR7cmVtb3RlUGF0aH0nOiAke2Vyci5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIEluc3RhbGxzIHRoZSBnaXZlbiBjZXJ0aWZpY2F0ZSBvbiBhIHJvb3RlZCByZWFsIGRldmljZSBvclxuICogYW4gZW11bGF0b3IuIFRoZSBlbXVsYXRvciBtdXN0IGJlIGV4ZWN1dGVkIHdpdGggYC13cml0YWJsZS1zeXN0ZW1gXG4gKiBjb21tYW5kIGxpbmUgb3B0aW9uIGFuZCBhZGIgZGFlbW9uIHNob3VsZCBiZSBydW5uaW5nIGluIHJvb3RcbiAqIG1vZGUgZm9yIHRoaXMgbWV0aG9kIHRvIHdvcmsgcHJvcGVybHkuIFRoZSBtZXRob2QgYWxzbyByZXF1aXJlc1xuICogb3BlbnNzbCB0b29sIHRvIGJlIGF2YWlsYWJsZSBvbiB0aGUgZGVzdGluYXRpb24gc3lzdGVtLlxuICogUmVhZCBodHRwczovL2dpdGh1Yi5jb20vYXBwaXVtL2FwcGl1bS9pc3N1ZXMvMTA5NjRcbiAqIGZvciBtb3JlIGRldGFpbHMgb24gdGhpcyB0b3BpY1xuICpcbiAqIEBwYXJhbSB7QnVmZmVyfHN0cmluZ30gY2VydCAtIGJhc2U2NC1kZWNvZGVkIGNvbnRlbnQgb2YgdGhlIGFjdHVhbCBjZXJ0aWZpY2F0ZVxuICogcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcgb3IgYSBidWZmZXJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBvcGVuc3NsIHRvb2wgaXMgbm90IGF2YWlsYWJsZSBvbiB0aGUgZGVzdGluYXRpb24gc3lzdGVtXG4gKiBvciBpZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaW5zdGFsbGluZyB0aGUgY2VydGlmaWNhdGVcbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuaW5zdGFsbE1pdG1DZXJ0aWZpY2F0ZSA9IGFzeW5jIGZ1bmN0aW9uIGluc3RhbGxNaXRtQ2VydGlmaWNhdGUgKGNlcnQpIHtcbiAgY29uc3Qgb3BlblNzbCA9IGF3YWl0IGdldE9wZW5Tc2xGb3JPcygpO1xuXG4gIGlmICghXy5pc0J1ZmZlcihjZXJ0KSkge1xuICAgIGNlcnQgPSBCdWZmZXIuZnJvbShjZXJ0LCAnYmFzZTY0Jyk7XG4gIH1cblxuICBjb25zdCB0bXBSb290ID0gYXdhaXQgdGVtcERpci5vcGVuRGlyKCk7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3JjQ2VydCA9IHBhdGgucmVzb2x2ZSh0bXBSb290LCAnc291cmNlLmNlcicpO1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShzcmNDZXJ0LCBjZXJ0KTtcbiAgICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKG9wZW5Tc2wsIFsneDUwOScsICctbm9vdXQnLCAnLWhhc2gnLCAnLWluJywgc3JjQ2VydF0pO1xuICAgIGNvbnN0IGNlcnRIYXNoID0gc3Rkb3V0LnRyaW0oKTtcbiAgICBsb2cuZGVidWcoYEdvdCBjZXJ0aWZpY2F0ZSBoYXNoOiAke2NlcnRIYXNofWApO1xuICAgIGxvZy5kZWJ1ZygnUHJlcGFyaW5nIGNlcnRpZmljYXRlIGNvbnRlbnQnKTtcbiAgICAoe3N0ZG91dH0gPSBhd2FpdCBleGVjKG9wZW5Tc2wsIFsneDUwOScsICctaW4nLCBzcmNDZXJ0XSwge2lzQnVmZmVyOiB0cnVlfSkpO1xuICAgIGxldCBkc3RDZXJ0Q29udGVudCA9IHN0ZG91dDtcbiAgICAoe3N0ZG91dH0gPSBhd2FpdCBleGVjKG9wZW5Tc2wsIFsneDUwOScsXG4gICAgICAnLWluJywgc3JjQ2VydCxcbiAgICAgICctdGV4dCcsXG4gICAgICAnLWZpbmdlcnByaW50JyxcbiAgICAgICctbm9vdXQnXSwge2lzQnVmZmVyOiB0cnVlfSkpO1xuICAgIGRzdENlcnRDb250ZW50ID0gQnVmZmVyLmNvbmNhdChbZHN0Q2VydENvbnRlbnQsIHN0ZG91dF0pO1xuICAgIGNvbnN0IGRzdENlcnQgPSBwYXRoLnJlc29sdmUodG1wUm9vdCwgYCR7Y2VydEhhc2h9LjBgKTtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoZHN0Q2VydCwgZHN0Q2VydENvbnRlbnQpO1xuICAgIGxvZy5kZWJ1ZygnUmVtb3VudGluZyAvc3lzdGVtIGluIHJ3IG1vZGUnKTtcbiAgICAvLyBTb21ldGltZXMgZW11bGF0b3IgcmVib290IGlzIHN0aWxsIG5vdCBmdWxseSBmaW5pc2hlZCBvbiB0aGlzIHN0YWdlLCBzbyByZXRyeVxuICAgIGF3YWl0IHJldHJ5SW50ZXJ2YWwoNSwgMjAwMCwgYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5hZGJFeGVjKFsncmVtb3VudCddKSk7XG4gICAgbG9nLmRlYnVnKGBVcGxvYWRpbmcgdGhlIGdlbmVyYXRlZCBjZXJ0aWZpY2F0ZSBmcm9tICcke2RzdENlcnR9JyB0byAnJHtDRVJUU19ST09UfSdgKTtcbiAgICBhd2FpdCB0aGlzLnB1c2goZHN0Q2VydCwgQ0VSVFNfUk9PVCk7XG4gICAgbG9nLmRlYnVnKCdSZW1vdW50aW5nIC9zeXN0ZW0gdG8gY29uZmlybSBjaGFuZ2VzJyk7XG4gICAgYXdhaXQgdGhpcy5hZGJFeGVjKFsncmVtb3VudCddKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgaW5qZWN0IHRoZSBjdXN0b20gY2VydGlmaWNhdGUuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgSXMgdGhlIGNlcnRpZmljYXRlIHByb3Blcmx5IGVuY29kZWQgaW50byBiYXNlNjQtc3RyaW5nPyBgICtcbiAgICAgICAgICAgICAgICAgICAgYERvIHlvdSBoYXZlIHJvb3QgcGVybWlzc2lvbnMgb24gdGhlIGRldmljZT8gYCArXG4gICAgICAgICAgICAgICAgICAgIGBPcmlnaW5hbCBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBmcy5yaW1yYWYodG1wUm9vdCk7XG4gIH1cbn07XG5cbi8qKlxuICogVmVyaWZpZXMgaWYgdGhlIGdpdmVuIHJvb3QgY2VydGlmaWNhdGUgaXMgYWxyZWFkeSBpbnN0YWxsZWQgb24gdGhlIGRldmljZS5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcnxzdHJpbmd9IGNlcnQgLSBiYXNlNjQtZGVjb2RlZCBjb250ZW50IG9mIHRoZSBhY3R1YWwgY2VydGlmaWNhdGVcbiAqIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nIG9yIGEgYnVmZmVyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgb3BlbnNzbCB0b29sIGlzIG5vdCBhdmFpbGFibGUgb24gdGhlIGRlc3RpbmF0aW9uIHN5c3RlbVxuICogb3IgaWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGNoZWNraW5nIHRoZSBjZXJ0aWZpY2F0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGdpdmVuIGNlcnRpZmljYXRlIGlzIGFscmVhZHkgaW5zdGFsbGVkXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmlzTWl0bUNlcnRpZmljYXRlSW5zdGFsbGVkID0gYXN5bmMgZnVuY3Rpb24gaXNNaXRtQ2VydGlmaWNhdGVJbnN0YWxsZWQgKGNlcnQpIHtcbiAgY29uc3Qgb3BlblNzbCA9IGF3YWl0IGdldE9wZW5Tc2xGb3JPcygpO1xuXG4gIGlmICghXy5pc0J1ZmZlcihjZXJ0KSkge1xuICAgIGNlcnQgPSBCdWZmZXIuZnJvbShjZXJ0LCAnYmFzZTY0Jyk7XG4gIH1cblxuICBjb25zdCB0bXBSb290ID0gYXdhaXQgdGVtcERpci5vcGVuRGlyKCk7XG4gIGxldCBjZXJ0SGFzaDtcbiAgdHJ5IHtcbiAgICBjb25zdCB0bXBDZXJ0ID0gcGF0aC5yZXNvbHZlKHRtcFJvb3QsICdzb3VyY2UuY2VyJyk7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKHRtcENlcnQsIGNlcnQpO1xuICAgIGNvbnN0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhvcGVuU3NsLCBbJ3g1MDknLCAnLW5vb3V0JywgJy1oYXNoJywgJy1pbicsIHRtcENlcnRdKTtcbiAgICBjZXJ0SGFzaCA9IHN0ZG91dC50cmltKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJldHJpZXZlIHRoZSBjZXJ0aWZpY2F0ZSBoYXNoLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYElzIHRoZSBjZXJ0aWZpY2F0ZSBwcm9wZXJseSBlbmNvZGVkIGludG8gYmFzZTY0LXN0cmluZz8gYCArXG4gICAgICAgICAgICAgICAgICAgIGBPcmlnaW5hbCBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBmcy5yaW1yYWYodG1wUm9vdCk7XG4gIH1cbiAgY29uc3QgZHN0UGF0aCA9IHBhdGgucG9zaXgucmVzb2x2ZShDRVJUU19ST09ULCBgJHtjZXJ0SGFzaH0uMGApO1xuICBsb2cuZGVidWcoYENoZWNraW5nIGlmIHRoZSBjZXJ0aWZpY2F0ZSBpcyBhbHJlYWR5IGluc3RhbGxlZCBhdCAnJHtkc3RQYXRofSdgKTtcbiAgcmV0dXJuIGF3YWl0IHRoaXMuZmlsZUV4aXN0cyhkc3RQYXRoKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHN5c3RlbUNhbGxNZXRob2RzO1xuZXhwb3J0IHsgREVGQVVMVF9BREJfRVhFQ19USU1FT1VUIH07XG4iXSwiZmlsZSI6ImxpYi90b29scy9zeXN0ZW0tY2FsbHMuanMiLCJzb3VyY2VSb290IjoiLi4vLi4vLi4ifQ==
